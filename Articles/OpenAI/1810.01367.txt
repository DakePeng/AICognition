8
1
0
2

t
c
O
2
2

]

G
L
.
s
c
[

3
v
7
6
3
1
0
.
0
1
8
1
:
v
i
X
r
a

Under review as a conference paper at ICLR 2019

FFJORD: FREE-FORM CONTINUOUS DYNAMICS FOR
SCALABLE REVERSIBLE GENERATIVE MODELS

Will Grathwohl∗†‡, Ricky T. Q. Chen∗†, Jesse Bettencourt†, Ilya Sutskever‡, David Duvenaud†

ABSTRACT

A promising class of generative models maps points from a simple distribution to
a complex distribution through an invertible neural network. Likelihood-based
training of these models requires restricting their architectures to allow cheap
computation of Jacobian determinants. Alternatively, the Jacobian trace can be
used if the transformation is speciﬁed by an ordinary differential equation. In this
paper, we use Hutchinson’s trace estimator to give a scalable unbiased estimate of
the log-density. The result is a continuous-time invertible generative model with
unbiased density estimation and one-pass sampling, while allowing unrestricted
neural network architectures. We demonstrate our approach on high-dimensional
density estimation, image generation, and variational inference, achieving the
state-of-the-art among exact likelihood methods with efﬁcient sampling.

1

INTRODUCTION

Reversible generative models use cheaply invertible neu-
ral networks to transform samples from a ﬁxed base distri-
bution. Examples include NICE (Dinh et al., 2014), Real
NVP (Dinh et al., 2017), and Glow (Kingma & Dhariwal,
2018). These models are easy to sample from, and can be
trained by maximum likelihood using the change of vari-
ables formula. However, this requires placing awkward
restrictions on their architectures, such as partitioning di-
mensions or using rank one weight matrices, in order to
avoid an O(D3) cost determinant computation.

Recently, Chen et al. (2018) introduced a continuous-time
analog of normalizing ﬂows, deﬁning the mapping from
latent variables to data using ordinary differential equa-
tions (ODEs). In their model, the likelihood can be com-
puted using relatively cheap trace operations. A more
ﬂexible, but still restricted, family of network architec-
tures can be used to avoid this O(D2) time cost.

Extending this work, we introduce an unbiased stochas-
tic estimator of the likelihood that has O(D) time cost,
allowing completely unrestricted architectures. Further-
more, we have implemented GPU-based adaptive ODE
solvers to train and evaluate these models on modern
hardware. We call our approach Free-form Jacobian of
Reversible Dynamics (FFJORD).

Figure 1: FFJORD transforms a sim-
ple base distribution at t0 into the tar-
get distribution at t1 by integrating over
learned continuous dynamics.

∗Equal contribution. Order determined by coin toss. {wgrathwohl, rtqichen}@cs.toronto.edu
†University of Toronto and Vector Institute
‡OpenAI

1

p(z(t1))01tzp(z(t0)) 
 
 
 
 
 
Under review as a conference paper at ICLR 2019

2 BACKGROUND: GENERATIVE MODELS AND CHANGE OF VARIABLES

In contrast to directly parameterizing a normalized distribution (Oord et al., 2016; Germain et al.,
2015), the change of variables formula allows one to specify a complex normalized distribu-
tion implicitly by warping a normalized base distribution pz(z) through an invertible function
f : RD → RD. Given a random variable z ∼ pz(z) the log density of x = f (z) follows

log px(x) = log pz(z) − log det

(1)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

∂f (z)
∂z

(cid:12)
(cid:12)
(cid:12)
(cid:12)

where ∂f (z)/∂z is the Jacobian of f . In general, computation of the log determinant has a time cost of
O(D3). Much work have gone into using restricted neural network architectures to make computing
the Jacobian determinant more tractable. These approaches broadly fall into three categories:

Normalizing ﬂows. By restricting the functional form of f , various determinant identities can
be exploited (Rezende & Mohamed, 2015; Berg et al., 2018). These models cannot be trained
directly on data and be able to sample because they do not have a tractable analytic inverse f −1
but have been shown to be useful in representing the approximate posterior for variational infer-
ence (Kingma & Welling, 2014).
Autoregressive transformations. By using an autoregressive model and specifying an ordering
in the dimensions, the Jacobian of f is enforced to be lower triangular (Kingma et al., 2016; Oliva
et al., 2018). These models excel at density estimation for tabular datasets (Papamakarios et al.,
2017), but require D sequential evaluations of f to invert, which is prohibitive when D is large.
Partitioned transformations. Partitioning the dimensions and using afﬁne transformations makes
the determinant of the Jacobian cheap to compute, and the inverse f −1 computable with the same
cost as f (Dinh et al., 2014; 2017). This method allows the use of convolutional architectures,
excelling at density estimation for image data (Dinh et al., 2017; Kingma & Dhariwal, 2018).

Throughout this work, we refer to reversible generative models those that use the change of variables
to transform a base distribution to the model distribution while maintaining both efﬁcient density
estimation and efﬁcient sampling capabilities using a single pass of the model.

2.1 OTHER GENERATIVE MODELS

There exist several approaches to generative modeling approaches which don’t use the change of
variables equation for training. Generative adversarial networks (GANs) (Goodfellow et al., 2014)
use large, unrestricted neural networks to transform samples from a ﬁxed base distribution. Lack-
ing a closed-form likelihood, an auxiliary discriminator model must be trained to estimate various
divergences in order to provide a training signal. Autoregressive models (Germain et al., 2015;
Oord et al., 2016) directly specify the joint distribution p(x) as a sequence of explicit conditional
distributions using the product rule. These models require at least O(D) evaluations to sample
from.Variational autoencoders (VAEs) Kingma & Welling (2014) use an unrestricted architecture to
explicitly specify the conditional likelihood p(x|z), but can only efﬁciently provide a lower bound
on the marginal likelihood p(x).

2.2 CONTINUOUS NORMALIZING FLOWS

Chen et al. (2018) deﬁne a generative model for data x ∈ RD similar to those based on (1) which
replaces the warping function with an integral of continuous-time dynamics. The generative pro-
cess works by ﬁrst sampling from a base distribution z0 ∼ pz0(z0). Then, given an ODE deﬁned
by the parametric function f (z(t), t; θ), we solve the initial value problem z(t0) = z0, ∂z(t)/∂t =
f (z(t), t; θ) to obtain z(t1) which constitutes our observable data. These models are called Con-
tinous Normalizing Flows (CNF). The change in log-density under this model follows a second
differential equation, called the instantaneous change of variables formula: (Chen et al., 2018),

∂ log p(z(t))
∂t

= − Tr

(cid:18) ∂f
∂z(t)

(cid:19)

.

We can compute total change in log-density by integrating across time:
(cid:19)

(cid:90) t1

log p(z(t1)) = log p(z(t0)) −

Tr

(cid:18) ∂f
∂z(t)

t0

2

(2)

(3)

dt.

Under review as a conference paper at ICLR 2019

Method

Train on
data

One-pass
Sampling

Exact log-
likelihood

Free-form
Jacobian

Variational Autoencoders
Generative Adversarial Nets
Likelihood-based Autoregressive

f
o

e
g
n
a
h
C

s
e
l
b
a
i
r
a
V

Normalizing Flows
Reverse-NF, MAF, TAN
NICE, Real NVP, Glow, Planar CNF
FFJORD

(cid:51)
(cid:51)
(cid:51)

(cid:55)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:55)

(cid:51)
(cid:55)
(cid:51)
(cid:51)

(cid:55)
(cid:55)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:55)

(cid:55)
(cid:55)
(cid:55)
(cid:51)

Table 1: A comparison of the abilities of generative modeling approaches.

Given a datapoint x, we can compute both the point z0 which generates x, as well as log p(x) under
the model by solving the initial value problem:

(cid:21)
(cid:20)
z0
log p(x) − log pz0(z0)
(cid:123)(cid:122)
solutions

(cid:125)

(cid:124)

=

(cid:90) t0

t1

(cid:124)

(cid:35)

(cid:34) f (z(t), t; θ)
(cid:17)
− Tr

(cid:16) ∂f
∂z(t)

(cid:123)(cid:122)
dynamics

,
dt

(cid:125)

(cid:20)
z(t1)
log p(x) − log p(z(t1))

(cid:21)

=

(cid:124)

(cid:123)(cid:122)
initial values

(cid:21)

(cid:20)x
0

(cid:125)

(4)

which integrates the combined dynamics of z(t) and the log-density of the sample backwards in
time from t1 to t0. We can then compute log p(x) using the solution of (4) and adding log pz0(z0).
The existence and uniqueness of (4) require that f and its ﬁrst derivatives be Lipschitz continu-
ous (Khalil, 2002), which can be satisﬁed in practice using neural networks with smooth Lipschitz
activations.

2.2.1 BACKPROPAGATING THROUGH ODE SOLUTIONS WITH THE ADJOINT METHOD

CNFs are trained to maximize (3). This objective involves the solution to an initial value problem
with dynamics parameterized by θ. For any scalar loss function which operates on the solution to an
initial value problem

L(z(t1)) = L

(cid:19)

f (z(t), t; θ)dt

(cid:18)(cid:90) t1

t0

then Pontryagin (1962) shows that its derivative takes the form of another initial value problem

dL
dθ

= −

(cid:90) t0

t1

(cid:18) ∂L
∂z(t)

(cid:19)T ∂f (z(t), t; θ)

∂θ

dt.

(5)

(6)

The quantity −∂L/∂z(t) is known as the adjoint state of the ODE. Chen et al. (2018) use a black-box
ODE solver to compute z(t1), and then another call to a solver to compute (6) with the initial value
∂L/∂z(t1). This approach is a continuous-time analog to the backpropgation algorithm (Rumelhart
et al., 1986; Andersson, 2013) and can be combined with gradient-based optimization methods to ﬁt
the parameters θ.

3 SCALABLE DENSITY EVALUATION WITH UNRESTRICTED ARCHITECTURES

Switching from discrete-time dynamics to continuous-time dynamics reduces the primary computa-
tional bottleneck of normalizing ﬂows from O(D3) to O(D2), at the cost of introducing a numerical
ODE solver. This allows the use of more expressive architectures. For example, each layer of the
original normalizing ﬂows model of Rezende & Mohamed (2015) is a one-layer neural network with
only a single hidden unit. In contrast, the instantaneous transformation used in planar continuous
normalizing ﬂows (Chen et al., 2018) is a one-layer neural network with many hidden units. In this
section, we construct an unbiased estimate of the log-density with O(D) cost, allowing completely
unrestricted neural network architectures to be used.

3

Under review as a conference paper at ICLR 2019

3.1 UNBIASED LINEAR-TIME LOG-DENSITY ESTIMATION

In general, computing Tr (∂f/∂z(t)) exactly costs O(D2), or approximately the same cost as D
evaluations of f , since each entry of the diagonal of the Jacobian requires computing a separate
derivative of f . However, there are two tricks that can help. First, vector-Jacobian products vT ∂f
∂z
can be computed for approximately the same cost as evaluating f , using reverse-mode automatic
differentiation. Second, we can get an unbiased estimate of the trace of a matrix by taking a double
product of that matrix with a noise vector:

Tr(A) = Ep((cid:15))[(cid:15)T A(cid:15)].

(7)

The above equation holds for any D-by-D matrix A and distribution p((cid:15)) over D-dimensional vec-
tors such that E[(cid:15)] = 0 and Cov((cid:15)) = I. The Monte Carlo estimator derived from (7) is known as
the Hutchinson’s trace estimator (Hutchinson, 1989; Adams et al., 2018).

To keep the dynamics deterministic within each call to the ODE solver, we can use a ﬁxed noise
vector (cid:15) for the duration of each solve without introducing bias:

log p(z(t1)) = log p(z(t0)) −

= log p(z(t0)) −

(cid:90) t1

t0
(cid:90) t1

t0

= log p(z(t0)) − Ep((cid:15))

Tr

(cid:19)

dt

(cid:18) ∂f
∂z(t)
(cid:20)
(cid:15)T ∂f
∂z(t)
(cid:15)T ∂f
∂z(t)

t0

Ep((cid:15))

(cid:20)(cid:90) t1

(cid:21)

(cid:15)

dt

(cid:21)

(cid:15)dt

(8)

Typical choices of p((cid:15)) are a standard Gaussian or Rademacher distribution (Hutchinson, 1989).

3.1.1 REDUCING VARIANCE WITH BOTTLENECK CAPACITY

Often, there exist bottlenecks in the architecture of the dynamics network, i.e. hidden layers whose
width H is smaller than the dimensions of the input D. In such cases, we can reduce the variance
of Hutchinson’s estimator by using the cyclic property of trace. Since the variance of the estimator
for Tr(A) grows asymptotic to ||A||2
F (Hutchinson, 1989), we suspect that having fewer dimensions
should help reduce variance.
If we view view the dynamics as a composition of two functions
f = g ◦ h(z) then we observe

Tr

(cid:19)

(cid:18) ∂f
∂z
(cid:124) (cid:123)(cid:122) (cid:125)
D×D

= Tr

(cid:18) ∂g
∂h

∂h
∂z

(cid:124)

(cid:123)(cid:122)
D×D

(cid:19)

(cid:125)

= Tr

(cid:18) ∂h
∂z

∂g
∂h

(cid:124)

(cid:123)(cid:122)
H×H

(cid:19)

(cid:125)

= Ep((cid:15))

(cid:20)
(cid:15)T ∂h
∂z

∂g
∂h

(cid:21)

(cid:15)

.

(9)

When f has multiple hidden layers, we choose H to be the smallest dimension. This bottleneck trick
can reduce the norm of the matrix which may also help reduce the variance of the trace estimator.

3.2 FFJORD: A CONTINUOUS-TIME REVERSIBLE GENERATIVE MODEL

Our complete method uses the dynamics deﬁned in (2) and the efﬁcient log-likelihood estimator of
(8) to produce the ﬁrst scalable and reversible generative model with an unconstrained Jacobian,
leading to the name Free-Form Jacobian of Reversible Dyanamics (FFJORD). Pseudo-code of our
method is given in Algorithm 1, and Table 1 summarizes the capabilities of our model compared to
previous work.

Assuming the cost of evaluating f is on the order of O(DH) where D is the dimensionality of the
data and H is the size of the largest hidden dimension in f , then the cost of computing the likelihood
in models which stack transformations that exploit (1) is O((DH +D3)L) where L is the number of
transformations used. For CNF, this reduces to O((DH + D2) ˆL) for CNFs, where ˆL is the number
of evaluations of f used by the ODE solver. With FFJORD, this reduces further to O((DH + D) ˆL).

4

Under review as a conference paper at ICLR 2019

Algorithm 1 Unbiased stochastic log-density estimation using the FFJORD model
Require: dynamics fθ, start time t0, stop time t1, minibatch of samples x.

(cid:15) ← sample unit variance(x.shape)
function faug([zt, log pt], t):

ft ← fθ(z(t), t)
(cid:12)
g ← (cid:15)T ∂f
(cid:12)z(t)
∂z
(cid:101)Tr = matrix multiply(g, (cid:15))
return [ft, − (cid:101)Tr]

(cid:46) Sample (cid:15) outside of the integral
(cid:46) Augment f with log-density dynamics.
(cid:46) Evaluate dynamics
(cid:46) Compute vector-Jacobian product with automatic differentiation
∂z ) with (cid:15)T ∂f
∂z (cid:15)
(cid:46) Concatenate dynamics of state and log-density

(cid:46) Unbiased estimate of Tr( ∂f

end function
[z, ∆logp] ← odeint(faug, [x,(cid:126)0], t0, t1)
log ˆp(x) ← log pz0 (z) - ∆logp
return log ˆp(x)

(cid:46) Solve the ODE, ie. (cid:82) t1
t0

faug([z(t), log p(z(t))], t) dt
(cid:46) Add change in log-density

4 EXPERIMENTS

We demonstrate the power of FFJORD on a va-
riety of density estimation tasks as well as ap-
proximate inference within variational autoen-
coders (Kingma & Welling, 2014). Experi-
ments were conducted using a suite of GPU-
based ODE-solvers and an implementation of
the adjoint method for backpropagation 1.
In
all experiments the Runge-Kutta 4(5) algorithm
with the tableau from Shampine (1986) was
used to solve the ODEs. We ensure tolerance
is set low enough so numerical error is negligi-
ble; see Appendix C.

We used Hutchinson’s trace estimator (7) dur-
ing training and the exact trace when report-
ing test results. This was done in all experi-
ments except for our density estimation models
trained on MNIST and CIFAR10 where com-
puting the exact Jacobian trace was not compu-
tationally feasible. There, we observed that the
variance of the log-likelihood over the valida-
tion set induced by the trace estimator is less
than 10−4.

Data

Glow

FFJORD

Figure 2: Comparison of trained FFJORD and
Glow models on 2-dimensional distributions in-
cluding multi-modal and discontinuous densities.

The dynamics of FFJORD are deﬁned by a neural network f which takes as input the current state
z(t) ∈ RD and the current time t ∈ R. We experimented with several ways to incorporate t as an
input to f , such as hyper-networks, but found that simply concatenating t on to z(t) at the input to
every layer worked well and was used in all of our experiments.

4.1 DENSITY ESTIMATION ON TOY 2D DATA

We ﬁrst train on 2 dimensional data to visualize the model and the learned dynamics.2 In Figure 2,
we show that by warping a simple isotropic Gaussian, FFJORD can ﬁt both multi-modal and even
discontinuous distributions. The number of evaluations of the ODE solver is roughly 70-100 on all
datasets, so we compare against a Glow model with 100 discrete layers.

The learned distributions of both FFJORD and Glow can be seen in Figure 2. Interestingly, we
ﬁnd that Glow learns to stretch the single mode base distribution into multiple modes but has trouble
modeling the areas of low probability between disconnected regions. In contrast, FFJORD is capable

1We plan on releasing the full code, including our GPU-based implementation of ODE solvers and the

adjoint method, upon publication.

2Videos of the learned dynamics can be found at https://imgur.com/a/Rtr3Mbq.

5

Under review as a conference paper at ICLR 2019

Samples

Data

Figure 3: Samples and data from our image models. MNIST on left, CIFAR10 on right.

POWER GAS HEPMASS MINIBOONE BSDS300

MNIST

CIFAR10

Real NVP
Glow
FFJORD

MADE
MAF
TAN
MAF-DDSF

-0.17
-0.17
-0.46

3.08
-0.24
-0.48
-0.62

-8.33
-8.15
-8.59

-3.56
-10.08
-11.19
-11.96

18.71
18.92
14.92

20.98
17.70
15.12
15.09

13.55
11.35
10.43

15.59
11.75
11.01
8.86

-153.28
-155.07
-157.40

-148.85
-155.69
-157.03
-157.73

1.06*
1.05*
0.99* (1.05†)

2.04
1.89
-
-

3.49*
3.35*
3.40*

5.67
4.31
-
-

Table 2: Negative log-likehood on test data for density estimation models; lower is better. In nats
for tabular data and bits/dim for MNIST and CIFAR10. *Results use multi-scale convolutional
architectures. †Results use a single ﬂow with a convolutional encoder-decoder architecture.

of modeling disconnected modes and can also learn convincing approximations of discontinuous
density functions (middle row in Figure 2).

4.2 DENSITY ESTIMATION ON REAL DATA

We perform density estimation on ﬁve tabular datasets preprocessed as in Papamakarios et al. (2017)
and two image datasets; MNIST and CIFAR10. On the tabular datasets, FFJORD performs the best
out of reversible models by a wide margin but is outperformed by recent autoregressive models. Of
those, FFJORD outperforms MAF (Papamakarios et al., 2017) on all but one dataset and manages
to outperform TAN Oliva et al. (2018) on the MINIBOONE dataset. These models require O(D)
sequential computations to sample from while the best performing method, MAF-DDSF (Huang
et al., 2018), cannot be sampled from analytically.

On MNIST we ﬁnd that FFJORD can model the data as well as Glow and Real NVP by integrating
a single ﬂow deﬁned by one neural network. This is in contrast to Glow and Real NVP which must
compose many ﬂows together to achieve similar performance. When we use multiple ﬂows in a
multiscale architecture (like those used by Glow and Real NVP) we obtain better performance on
MNIST and comparable performance to Glow on CIFAR10. Notably, FFJORD is able to achieve
this performance while using less than 2% as many parameters as Glow. We also note that Glow
uses a learned base distribution whereas FFJORD and Real NVP use a ﬁxed Gaussian. A summary
of our results on density estimation can be found in Table 2 and samples can be seen in Figure 3.
Full details on architectures used, our experimental procedure, and additional samples can be found
in Appendix B.1.

In general, our approach is slower than competing methods, but we ﬁnd the memory-efﬁciency of
the adjoint method allows us to use much larger batch sizes than those methods. On the tabular
datasets we used a batch sizes up to 10,000 and on the image datasets we used a batch size of 900.

4.3 VARIATIONAL AUTOENCODER

We compare FFJORD to other normalizing ﬂows for use in variational inference. We train a
VAE (Kingma & Welling, 2014) on four datasets using a FFJORD ﬂow and compare to VAEs with
no ﬂow, Planar Flows (Rezende & Mohamed, 2015), Inverse Autoregressive Flow (IAF) (Kingma
et al., 2016), and Sylvester normalizing ﬂows (Berg et al., 2018). To provide a fair comparison, our
encoder/decoder architectures and learning setup exactly mirror those of Berg et al. (2018).

6

Under review as a conference paper at ICLR 2019

MNIST

Omniglot

Frey Faces

Caltech Silhouettes

86.55 ± .06
No Flow
86.06 ± .31
Planar
84.20 ± .17
IAF
83.32 ± .06
Sylvester
FFJORD 82.82 ± .01

104.28 ± .39
102.65 ± .42
102.41 ± .04
99.00 ± .04
98.33 ± .09

4.53 ± .02
4.40 ± .06
4.47 ± .05
4.45 ± .04
4.39 ± .01

110.80 ± .46
109.66 ± .42
111.58 ± .38
104.62 ± .29
104.03 ± .43

Table 3: Negative ELBO on test data for VAE models; lower is better. In nats for all datasets except
Frey Faces which is presented in bits per dimension. Mean/stdev are estimated over 3 runs.

In VAEs it is common for the encoder network to also output the parameters of the ﬂow as a function
of the input x. With FFJORD, we found this led to differential equations which were too difﬁcult
to integrate numerically. Instead, the encoder network outputs a low-rank update to a global weight
matrix and an input-dependent bias vector. Neural network layers inside of FFJORD take the form

layer(h; x, W, b) = σ











 W
(cid:124)(cid:123)(cid:122)(cid:125)
Dout×Din

+ ˆU (x)
(cid:124) (cid:123)(cid:122) (cid:125)
Dout×k

ˆV (x)
(cid:124) (cid:123)(cid:122) (cid:125)
Din×k

T

 h + b

(cid:124)(cid:123)(cid:122)(cid:125)
Dout×1

+ ˆb(x)
(cid:124)(cid:123)(cid:122)(cid:125)
Dout×1



(10)

where h is the input to the layer, σ is an element-wise activation function, Din and Dout are the
input and output dimensionality of this layer, and ˆU (x), ˆV (x), ˆb(x) are data-dependent parameters
returned from the encoder networks. A full description of the model architectures used and our
experimental setup can be found in Appendix B.2.

On every dataset tested, FFJORD outperforms all other competing normalizing ﬂows. A summary
of our variational inference results can be found in Table 3.

5 ANALYSIS AND DISCUSSION

We perform a series of ablation experiments to gain a bet-
ter understanding of the proposed model.

5.1 FASTER TRAINING WITH BOTTLENECK TRICK

We plot the training losses on MNIST using an encoder-
decoder architecture (see Appendix B.1 for details). Loss
during training is plotted in Figure 4, where we use the
trace estimator directly on the D × D Jacobian or we use
the bottleneck trick to reduce the dimension to H × H.
Interestingly, we ﬁnd that while the bottleneck trick (9)
can lead to faster convergence when the trace is estimated
using a Gaussian-distributed (cid:15), we did not observe faster
convergence when using a Rademacher-distributed (cid:15).

5.2 NUMBER OF FUNCTION EVALUATIONS VS.
DATA DIMENSION

Figure 4: The variance of our model’s
log-density estimator can be reduced us-
ing neural network architectures with a
bottleneck layer, speeding up training.

The full computational cost of integrating the instanta-
neous change of variables (2) is O(DH (cid:98)L) where D is di-
mensionality of the data, H is the size of the hidden state,
and (cid:98)L is the number of function evaluations (NFE) that
the adaptive solver uses to integrate the ODE. In general,
each evaluation of the model is O(DH) and in practice,
H is typically chosen to be close to D. Since the gen-
eral form of the discrete change of variables equation (1)
requires O(D3)-cost, one may wonder whether the number of evaluations (cid:98)L depends on D.

Figure 5: Number of function evaluates
used by the adaptive ODE solver (NFE)
is approximately independent of data-
dimension.

7

0255075100125150Epoch1.11.21.31.41.51.61.7Bits/dimGaussian w/o TrickGaussian w/ TrickRademacher w/o TrickRademacher w/ Trick050100150200250Epoch20.022.525.027.530.032.5NFEDim 16Dim 32Dim 48Dim 64Under review as a conference paper at ICLR 2019

We train VAEs using FFJORD ﬂows with increasing latent dimension D. The NFE throughout
training is shown in Figure 5. In all models, we ﬁnd that the NFE increases throughout training,
but converges to the same value, independent of D. This phenomenon can be veriﬁed with a simple
thought experiment. Take an RD isotropic Gaussian distribution as the data distribution and set the
base distribution of our model to be an isotropic Gaussian. Then the optimal differential equation is
zero for any D, and the number evaluations is zero. We can conclude that the number of evaluations
is not dependent on the dimensionality of the data but the complexity of its distribution, or more
speciﬁcally, how difﬁcult it is to transform its density into the base distribution.

5.3 SINGLE-SCALE VS. MULTI-SCALE FFJORD

Crucial to the scalability of Real NVP and Glow is the
multiscale architecture originally proposed in Dinh et al.
(2017). We compare an single-scale encoder-decoder
style FFJORD with a multiscale FFJORD on the MNIST
dataset where both models have a comparable number of
parameters and plot the total NFE–in both forward and
backward passes–against the loss achieved in Figure 6.
We ﬁnd that while the single-scale model uses approxi-
mately one half as many function evaluations as the mul-
tiscale model, it is not able to achieve the same perfor-
mance as the multiscale model.

6 SCOPE AND LIMITATIONS

Figure 6: For image data, multiscale ar-
chitectures require the ODE solver to
use a greater number of function evalu-
ations (NFE), but these models achieve
better performance.

Number of function evaluations can be prohibitive. The number of function evaluations re-
quired to integrate the dynamics is not ﬁxed ahead of time and is a function of the data, model
architecture, and model parameters. We ﬁnd that this tends to grow as the models trains and can
become prohibitively large, even when memory stays constant due to the adjoint method. Various
forms of regularization such as weight decay and spectral normalization (Miyato et al., 2018) can
be used to reduce the this quantity but their use tends to hurt performance slightly.

Limitations of general-purpose ODE solvers.
In theory, we can model any differential equation
(given mild assumptions based on existence and uniqueness of the solution), but in practice our
reliance on general-purpose ODE solvers restricts us to non-stiff differential equations that can be
efﬁciently solved. ODE solvers for stiff dynamics exist, but they evaluate f many more times to
achieve the same error. We ﬁnd that using a small amount of weight decay sufﬁciently constrains
the ODE to be non-stiff.

7 CONCLUSION

We have presented FFJORD, a reversible generative model for high dimensional data which can
compute exact log-likelihoods and can be sampled from efﬁciently. Our model uses continuous-time
dynamics to produce a generative model which is parameterized by an unrestricted neural network.
All required quantities for training and sampling can be computed using automatic-differentiation,
Hutchinson’s trace estimator, and black-box ODE solvers. Our model stands in contrast to other
methods with similar properties which rely on restricted, hand-engineered neural network architec-
tures. We have demonstrated that this additional ﬂexibility allows our approach to achieve improved
performance on density estimation and variational inference. We also demonstrate FFJORD’s ability
to model distributions which comparable methods such as Glow and Real NVP cannot model.

We believe there is much room for further work exploring and improving this method. We are
interested speciﬁcally in ways to reduce the number of function evaluations used by the ODE-solver
without hurting predictive performance. Advancements like these will be crucial in scaling this
method to even higher-dimensional datasets.

8

250500750NFE1.001.251.501.752.00Bits/dimSingle FFJORDMultiscale FFJORDUnder review as a conference paper at ICLR 2019

8 ACKNOWLEDGEMENTS

We thank Roger Grosse and Yulia Rubanova for helpful discussions.

REFERENCES

R. P. Adams, J. Pennington, M. J. Johnson, J. Smith, Y. Ovadia, B. Patton, and J. Saunderson.

Estimating the Spectral Density of Large Implicit Matrices. ArXiv e-prints, February 2018.

Joel Andersson. A general-purpose software framework for dynamic optimization. PhD thesis, 2013.

Rianne van den Berg, Leonard Hasenclever, Jakub M Tomczak, and Max Welling. Sylvester nor-

malizing ﬂows for variational inference. arXiv preprint arXiv:1803.05649, 2018.

Ricky T. Q. Chen, Yulia Rubanova, Jesse Bettencourt, and David Duvenaud. Neural ordinary dif-

ferential equations. Advances in Neural Information Processing Systems, 2018.

Laurent Dinh, David Krueger, and Yoshua Bengio. NICE: Non-linear independent components

estimation. International Conference on Learning Representations Workshop, 2014.

Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using Real NVP. In-

ternational Conference on Learning Representations, 2017.

Mathieu Germain, Karol Gregor, Iain Murray, and Hugo Larochelle. Made: Masked autoencoder for
distribution estimation. In International Conference on Machine Learning, pp. 881–889, 2015.

Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in neural infor-
mation processing systems, pp. 2672–2680, 2014.

Chin-Wei Huang, David Krueger, Alexandre Lacoste, and Aaron Courville. Neural autoregressive

ﬂows. International Conference on Machine Learning, 2018.

M.F. Hutchinson. A stochastic estimator of the trace of the inﬂuence matrix for laplacian smoothing

splines. 18:1059–1076, 01 1989.

H.K. Khalil. Nonlinear Systems. Pearson Education. Prentice Hall, 2002.

Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint

arXiv:1412.6980, 2014.

Diederik P Kingma and Prafulla Dhariwal. Glow: Generative ﬂow with invertible 1x1 convolutions.

arXiv preprint arXiv:1807.03039, 2018.

Diederik P Kingma and Max Welling. Auto-encoding variational bayes. International Conference

on Learning Representations, 2014.

Diederik P Kingma, Tim Salimans, Rafal Jozefowicz, Xi Chen, Ilya Sutskever, and Max Welling.
Improved variational inference with inverse autoregressive ﬂow. In Advances in Neural Informa-
tion Processing Systems, pp. 4743–4751, 2016.

Takeru Miyato, Toshiki Kataoka, Masanori Koyama, and Yuichi Yoshida. Spectral normalization for
generative adversarial networks. International Conference on Learning Representations, 2018.

Junier B Oliva, Avinava Dubey, Barnab´as P´oczos, Jeff Schneider, and Eric P Xing. Transformation

autoregressive networks. International Conference on Machine Learning, 2018.

Aaron van den Oord, Nal Kalchbrenner, and Koray Kavukcuoglu. Pixel recurrent neural networks.

International Conference on Machine Learning, 2016.

George Papamakarios, Iain Murray, and Theo Pavlakou. Masked autoregressive ﬂow for density

estimation. In Advances in Neural Information Processing Systems, pp. 2338–2347, 2017.

Lev Semenovich Pontryagin. Mathematical theory of optimal processes. Routledge, 1962.

9

Under review as a conference paper at ICLR 2019

Danilo Jimenez Rezende and Shakir Mohamed. Variational inference with normalizing ﬂows. In-

ternational Conference on Machine Learning, 2015.

David E Rumelhart, Geoffrey E Hinton, and Ronald J Williams. Learning representations by back-

propagating errors. nature, 323(6088):533, 1986.

Lawrence F Shampine. Some practical Runge-Kutta formulas. Mathematics of Computation, 46

(173):135–150, 1986.

10

Under review as a conference paper at ICLR 2019

s
e
l
p
m
a
S

a
t
a
D

Figure 7: Samples and data from our image models. MNIST on left, CIFAR10 on right.

APPENDIX A QUALITATIVE SAMPLES

Samples from our FFJORD models trained on MNIST and CIFAR10 can be found in Figure 7.

APPENDIX B EXPERIMENTAL DETAILS AND ADDITIONAL RESULTS

B.1 DENSITY ESTIMATION

On the tabular datasets we performed a grid-search over network architectures. We searched over
models with 1, 2, 5, or 10 ﬂows with 1, 2, 3, or 4 hidden layers per ﬂow. Since each dataset has
a different number of dimensions, we searched over hidden dimensions equal to 5, 10, or 20 times
the data dimension (hidden dimension multiplier in Table 4). We tried both the tanh and softplus
nonlinearities. The best performing models can be found in the Table 4.

On the image datasets we experimented with two different model architectures; a single ﬂow with
an encoder-decoder style architecture and a multiscale architecture composed of multiple ﬂows.

While they were able to ﬁt MNIST and obtain competitive performance, the encoder-decoder ar-
chitectures were unable to ﬁt more complicated image datasets such as CIFAR10 and Street View
House Numbers. The architecture for MNIST which obtained the results in Table 2 was composed
of four convolutional layers with 64 → 64 → 128 → 128 ﬁlters and down-sampling with strided
convolutions by two every other layer. There are then four transpose-convolutional layers who’s

11

Under review as a conference paper at ICLR 2019

ﬁlters mirror the ﬁrst four layers and up-sample by two every other layer. The softplus activation
function is used in every layer.

The multiscale architectures were inspired by those presented in Dinh et al. (2017). We compose
multiple ﬂows together interspersed with “squeeze” operations which down-sample the spatial reso-
lution of the images and increase the number of channels. These operations are stacked into a “scale
block” which contains N ﬂows, a squeeze, then N ﬂows. For MNIST we use 3 scale blocks and
for CIFAR10 we use 4 scale blocks and let N = 2 for both datasets. Each ﬂow is deﬁned by 3
convolutional layers with 64 ﬁlters and a kernel size of 3. The softplus nonlinearity is used in all
layers.

Both models were trained with the Adam optimizer (Kingma & Ba, 2014). We trained for 500
epochs with a learning rate of .001 which was decayed to .0001 after 250 epochs. Training took
place on six GPUs and completed after approximately ﬁve days.

B.2 VARIATIONAL AUTOENCODER

Our experimental procedure exactly mirrors that of Berg et al. (2018). We use the same 7-layer
encoder and decoder, learning rate (.001), optimizer (Adam Kingma & Ba (2014)), batch size (100),
and early stopping procedure (stop after 100 epochs of no validaiton improvment). The only differ-
ence was in the nomralizing ﬂow used in the approximate posterior.

We performed a grid-search over neural network architectures for the dynamics of FFJORD. We
searched over networks with 1 and 2 hidden layers and hidden dimension 512, 1024, and 2048. We
used ﬂows with 1, 2, or 5 steps and wight matrix updates of rank 1, 20, and 64. We use the softplus
activation function for all datasets except for Caltech Silhouettes where we used tanh. The best
performing models can be found in the Table 5. Models were trained on a single GPU and training
took between four hours and three days depending on the dataset.

Dataset

nonlinearity

# layers

hidden dim multiplier

# ﬂow steps

batchsize

POWER
GAS
HEPMASS
MINIBOONE
BSDS300

tanh
tanh
softplus
softplus
softplus

3
3
2
2
3

10
20
10
20
20

5
5
10
1
2

10000
1000
10000
1000
10000

Table 4: Best performing model architectures for density estimation on tabular data with FFJORD.

Dataset

nonlinearity

# layers

hidden dimension

# ﬂow steps

rank

MNIST
Omniglot
Frey Faces
Caltech

softplus
softplus
softplus
tanh

2
2
2
1

1024
512
512
2048

2
5
2
1

64
20
20
20

Table 5: Best performing model architectures for VAEs with FFJORD.

12

Under review as a conference paper at ICLR 2019

B.3 STANDARD DEVIATIONS FOR TABULAR DENSITY ESTIMATION

POWER

GAS

HEPMASS MINIBOONE

BSDS300

Real NVP
Glow
FFJORD

-0.17 ± 0.01
-0.17 ± 0.01
-0.46 ± 0.01

-8.33 ± 0.14
-8.15 ± 0.40
-8.59 ± 0.12

18.71 ± 0.02
18.92 ± 0.08
14.92 ± 0.08

13.55 ± 0.49
11.35 ± 0.07
10.43 ± 0.04

-153.28 ± 1.78
-155.07 ± 0.03
-157.40 ± 0.19

20.98 ± 0.02
-3.56 ± 0.04
3.08 ± 0.03
MADE
-0.24 ± 0.01 -10.08 ± 0.02 17.70 ± 0.02
MAF
-0.48 ± 0.01 -11.19 ± 0.02 15.12 ± 0.02
TAN
MAF-DDSF -0.62 ± 0.01 -11.96 ± 0.33 15.09 ± 0.40

15.59 ± 0.50
11.75 ± 0.44
11.01 ± 0.48
8.86 ± 0.15

-148.85 ± 0.28
-155.69 ± 0.28
-157.03 ± 0.07
-157.73 ± 0.04

Table 6: Negative log-likehood on test data for density estimation models. Means/stdev over 3 runs.

APPENDIX C NUMERICAL ERROR FROM THE ODE SOLVER

ODE solvers are numerical integration methods so there is error inherent in their outputs. Adaptive
solvers (like those used in all of our experiments) attempt to predict the errors that they accrue and
modify their step-size to reduce their error below a user set tolerance. It is important to be aware of
this error when we use these solvers for density estimation as the solver outputs the density that we
report and compare with other methods. When tolerance is too low, we run into machine precision
errors. Similarly when tolerance is too high, errors are large, our training objective becomes biased
and we can run into divergent training dynamics.

Since a valid probability density function integrates to one, we take a model trained on Figure 1 and
numerically ﬁnd the area under the curve using Riemann sum and a very ﬁne grid. We do this for a
range of tolerance values and show the resulting error in Figure 8. We set both atol and rtol to
the same tolerance.

Figure 8: Numerical integration shows that the density under the model does integrate to one given
sufﬁciently low tolerance. Both log and non-log plots are shown.

The numerical error follows the same order as the tolerance, as expected. During training, we ﬁnd
that the error becomes non-negligible when using tolerance values higher than 10−5. For most of
our experiments, we set tolerance to 10−5 as that gives reasonable performance while requiring few
number of evaluations. For the tabular experiments, we use atol=10−8 and rtol=10−6.

13

108107106105104103102101Solver Tolerance107105103101|1p(x)|108107106105104103102101Solver Tolerance0.0000.0050.0100.0150.0200.025|1p(x)|