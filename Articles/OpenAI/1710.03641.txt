8
1
0
2

b
e
F
3
2

]

G
L
.
s
c
[

2
v
1
4
6
3
0
.
0
1
7
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

CONTINUOUS ADAPTATION VIA META-LEARNING IN
NONSTATIONARY AND COMPETITIVE ENVIRONMENTS

Maruan Al-Shedivat∗
CMU

Trapit Bansal
UMass Amherst

Yura Burda
OpenAI

Ilya Sutskever
OpenAI

Igor Mordatch
OpenAI

Pieter Abbeel
UC Berkeley

ABSTRACT

The ability to continuously learn and adapt from limited experience in nonstationary
environments is an important milestone on the path towards general intelligence. In
this paper, we cast the problem of continuous adaptation into the learning-to-learn
framework. We develop a simple gradient-based meta-learning algorithm suitable
for adaptation in dynamically changing and adversarial scenarios. Additionally,
we design a new multi-agent competitive environment, RoboSumo, and deﬁne
iterated adaptation games for testing various aspects of continuous adaptation. We
demonstrate that meta-learning enables signiﬁcantly more efﬁcient adaptation than
reactive baselines in the few-shot regime. Our experiments with a population of
agents that learn and compete suggest that meta-learners are the ﬁttest.

1

INTRODUCTION

Recent progress in reinforcement learning (RL) has achieved very impressive results ranging from
playing games (Mnih et al., 2015; Silver et al., 2016), to applications in dialogue systems (Li et al.,
2016), to robotics (Levine et al., 2016). Despite the progress, the learning algorithms for solving
many of these tasks are designed to deal with stationary environments. On the other hand, real-world
is often nonstationary either due to complexity (Sutton et al., 2007), changes in the dynamics or the
objectives in the environment over the life-time of a system (Thrun, 1998), or presence of multiple
learning actors (Lowe et al., 2017; Foerster et al., 2017a). Nonstationarity breaks the standard
assumptions and requires agents to continuously adapt, both at training and execution time, in order
to succeed.

Learning under nonstationary conditions is challenging. The classical approaches to dealing with
nonstationarity are usually based on context detection (Da Silva et al., 2006) and tracking (Sutton
et al., 2007), i.e., reacting to the already happened changes in the environment by continuously
ﬁne-tuning the policy. Unfortunately, modern deep RL algorithms, while able to achieve super-human
performance on certain tasks, are known to be sample inefﬁcient. Nevertheless, nonstationarity allows
only for limited interaction before the properties of the environment change. Thus, it immediately
puts learning into the few-shot regime and often renders simple ﬁne-tuning methods impractical.

A nonstationary environment can be seen as a sequence of stationary tasks, and hence we propose to
tackle it as a multi-task learning problem (Caruana, 1998). The learning-to-learn (or meta-learning)
approaches (Schmidhuber, 1987; Thrun & Pratt, 1998) are particularly appealing in the few-shot
regime, as they produce ﬂexible learning rules that can generalize from only a handful of examples.
Meta-learning has shown promising results in the supervised domain and have gained a lot of attention
from the research community recently (e.g., Santoro et al., 2016; Ravi & Larochelle, 2016). In this
paper, we develop a gradient-based meta-learning algorithm similar to (Finn et al., 2017b) and suitable
for continuous adaptation of RL agents in nonstationary environments. More concretely, our agents
meta-learn to anticipate the changes in the environment and update their policies accordingly.

While virtually any changes in an environment could induce nonstationarity (e.g., changes in the
physics or characteristics of the agent), environments with multiple agents are particularly challenging

∗Correspondence: maruan.alshedivat.com. Work done while MA and TB interned at OpenAI.

1

 
 
 
 
 
 
Published as a conference paper at ICLR 2018

due to complexity of the emergent behavior and are of practical interest with applications ranging
from multiplayer games (Peng et al., 2017) to coordinating self-driving ﬂeets Cao et al. (2013).
Multi-agent environments are nonstationary from the perspective of any individual agent since all
actors are learning and changing concurrently (Lowe et al., 2017). In this paper, we consider the
problem of continuous adaptation to a learning opponent in a competitive multi-agent setting.

To this end, we design RoboSumo—a 3D environment with simulated physics that allows pairs of
agents to compete against each other. To test continuous adaptation, we introduce iterated adaptation
games—a new setting where a trained agent competes against the same opponent for multiple rounds
of a repeated game, while both are allowed to update their policies and change their behaviors between
the rounds. In such iterated games, from the agent’s perspective, the environment changes from
round to round, and the agent ought to adapt in order to win the game. Additionally, the competitive
component of the environment makes it not only nonstationary but also adversarial, which provides a
natural training curriculum and encourages learning robust strategies (Bansal et al., 2018).

We evaluate our meta-learning agents along with a number of baselines on a (single-agent) locomotion
task with handcrafted nonstationarity and on iterated adaptation games in RoboSumo. Our results
demonstrate that meta-learned strategies clearly dominate other adaptation methods in the few-shot
regime in both single- and multi-agent settings. Finally, we carry out a large-scale experiment
where we train a diverse population of agents with different morphologies, policy architectures, and
adaptation methods, and make them interact by competing against each other in iterated games. We
evaluate the agents based on their TrueSkills (Herbrich et al., 2007) in these games, as well as evolve
the population as whole for a few generations—the agents that lose disappear, while the winners get
duplicated. Our results suggest that the agents with meta-learned adaptation strategies end up being the
ﬁttest. Videos that demonstrate adaptation behaviors are available at https://goo.gl/tboqaN.

2 RELATED WORK

The problem of continuous adaptation considered in this work is a variant of continual learning
(Ring, 1994; 1997) and is related to lifelong (Thrun & Pratt, 1998; Silver et al., 2013) and never-
ending (Mitchell et al., 2015) learning. Life-long learning systems aim at solving multiple tasks
sequentially by efﬁciently transferring and utilizing knowledge from already learned tasks to new
tasks while minimizing the effect of catastrophic forgetting (McCloskey & Cohen, 1989). Never-
ending learning is concerned with mastering a ﬁxed set of tasks in iterations, where the set keeps
growing and the performance on all the tasks in the set keeps improving from iteration to iteration.

The scope of continuous adaptation is narrower and more precise. While life-long and never-ending
learning settings are deﬁned as general multi-task problems (Silver et al., 2013; Mitchell et al.,
2015), continuous adaptation targets to solve a single but nonstationary task or environment. The
nonstationarity in the former two problems exists and is dictated by the selected sequence of tasks.
In the latter case, we assume that nonstationarity is caused by some underlying dynamics in the
properties of a given task in the ﬁrst place (e.g., changes in the behavior of other agents in a multi-
agent setting). Finally, in the life-long and never-ending scenarios the boundary between training and
execution is blurred as such systems constantly operate in the training regime. Continuous adaptation,
on the other hand, expects a (potentially trained) agent to adapt to the changes in the environment at
execution time under the pressure of limited data or interaction experience between the changes1.

Nonstationarity of multi-agent environments is a well known issue that has been extensively studied
in the context of learning in simple multi-player iterated games (such as rock-paper-scissors) where
each episode is one-shot interaction (Singh et al., 2000; Bowling, 2005; Conitzer & Sandholm, 2007).
In such games, discovering and converging to a Nash equilibrium strategy is a success for the learning
agents. Modeling and exploiting opponents (Zhang & Lesser, 2010; Mealing & Shapiro, 2013) or
even their learning processes (Foerster et al., 2017b) is advantageous as it improves convergence or
helps to discover equilibria of certain properties (e.g., leads to cooperative behavior). In contrast,
each episode in RoboSumo consists of multiple steps, happens in continuous time, and requires
learning a good intra-episodic controller. Finding Nash equilibria in such a setting is hard. Thus, fast
adaptation becomes one of the few viable strategies against changing opponents.

1The limited interaction aspect of continuous adaptation makes the problem somewhat similar to the recently

proposed life-long few-shot learning (Finn et al., 2017a).

2

Published as a conference paper at ICLR 2018

θ

τθ

T

φ

τφ

(a)

. . .

φi−1

τi−1

. . .

Ti−1

φi+1

. . .

τi+1

Ti+1

. . .

φi

τi

Ti

(b)

(c)

Fig. 1: (a) A probabilistic model for MAML in a multi-task RL setting. The task, T , the policies, π, and the
trajectories, τ , are all random variables with dependencies encoded in the edges of the given graph. (b) Our
extended model suitable for continuous adaptation to a task changing dynamically due to non-stationarity of the
environment. Policy and trajectories at a previous step are used to construct a new policy for the current step. (c)
Computation graph for the meta-update from φi to φi+1. Boxes represent replicas of the policy graphs with the
speciﬁed parameters. The model is optimized via truncated backpropagation through time starting from LTi+1 .

Our proposed method for continuous adaptation follows the general meta-learning paradigm (Schmid-
huber, 1987; Thrun & Pratt, 1998), i.e., it learns a high-level procedure that can be used to generate
a good policy each time the environment changes. There is a wealth of work on meta-learning,
including methods for learning update rules for neural models that were explored in the past (Ben-
gio et al., 1990; 1992; Schmidhuber, 1992), and more recent approaches that focused on learning
optimizers for deep networks (Hochreiter et al., 2001; Andrychowicz et al., 2016; Li & Malik, 2016;
Ravi & Larochelle, 2016), generating model parameters (Ha et al., 2016; Edwards & Storkey, 2016;
Al-Shedivat et al., 2017), learning task embeddings (Vinyals et al., 2016; Snell et al., 2017) including
memory-based approaches (Santoro et al., 2016), learning to learn implicitly via RL (Wang et al.,
2016; Duan et al., 2016), or simply learning a good initialization (Finn et al., 2017b).

3 METHOD

The problem of continuous adaptation in nonstationary environments immediately puts learning
into the few-shot regime: the agent must learn from only limited amount of experience that it can
collect before its environment changes. Therefore, we build our method upon the previous work on
gradient-based model-agnostic meta-learning (MAML) that has been shown successful in the few-
shot settings (Finn et al., 2017b). In this section, we re-derive MAML for multi-task reinforcement
learning from a probabilistic perspective (cf. Grant et al., 2018), and then extend it to dynamically
changing tasks.

3.1 A PROBABILISTIC VIEW OF MODEL-AGNOSTIC META-LEARNING (MAML)

Assume that we are given a distribution over tasks,

(T ), where each task, T , is a tuple:

D

|

T := (LT , PT (x) , PT (xt+1

xt, at) , H)

(1)

, to a loss value, i.e., LT :

LT is a task-speciﬁc loss function that maps a trajectory, τ := (x0, a1, x1, R1, . . . , aH , xH , RH )

∈
xt, at) deﬁne the Markovian dynamics
T
of the environment in task T ; H denotes the horizon; observations, xt, and actions, at, are elements
(typically, vectors) of the observation space,
, respectively. The loss of a
trajectory, τ , is the negative cumulative reward, LT (τ ) :=

R; PT (x) and PT (xt+1

, and action space,

T (cid:55)→

(cid:80)H

X

|

A
t=1 Rt.

The goal of meta-learning is to ﬁnd a procedure which, given access to a limited experience on a
(T ), can produce a good policy for solving it. More formally, after querying
task sampled from
K trajectories from a task T
, we would like to construct a
new, task-speciﬁc policy, πφ, that would minimize the expected subsequent loss on the task T . In
particular, MAML constructs parameters of the task-speciﬁc policy, φ, using gradient of LT w.r.t. θ:

(T ) under policy πθ, denoted τ 1:K

∼ D

D

θ

−

φ := θ

α

∇

−

θLT

(cid:0)τ 1:K

θ

(cid:1) , where LT

(cid:0)τ 1:K

θ

(cid:1) :=

1
K

K
(cid:88)

k=1

3

LT (τ k

θ ), and τ k

θ ∼

PT (τ

θ)

|

(2)

+PolicyLossTrajectory+Intermediate stepsdeterministicstochasticgradientPublished as a conference paper at ICLR 2018

Algorithm 1 Meta-learning at training time.

Algorithm 2 Adaptation at execution time.

input A stream of tasks, T1, T2, T3, . . . .
1: Initialize φ = θ.
2: while there are new incoming tasks do
Get a new task, Ti, from the stream.
3:
Solve Ti using πφ policy.
4:
5: While solving Ti, collect trajectories, τ 1:K
i,φ .
6:

Update φ ← φ(τ 1:K
importance-corrected meta-update as in (9).

i,φ , θ∗, α∗) using

7: end while

input Distribution over pairs of tasks, P(Ti, Ti+1),

learning rate, β.

1: Randomly initialize θ and α.
2: repeat
3:
4:
5:
6:
7:
8:
9:

θ

Sample a batch of task pairs, {(Ti, Ti+1)}n
for all task pairs (Ti, Ti+1) in the batch do

i=1.

Sample traj. τ 1:K
Compute φ = φ(τ 1:K
θ
Sample traj. τφ from Ti+1 using πφ.

from Ti using πθ.

, θ, α) as given in (7).

end for
Compute ∇θLTi,Ti+1 and ∇αLTi,Ti+1 using
τ 1:K
and τφ as given in (8).
θ
Update θ ← θ + β∇θLT (θ, α).
Update α ← α + β∇αLT (θ, α).

10:
11:
12: until Convergence
output Optimal θ∗ and α∗.

We call (2) the adaptation update with a step α. The adaptation update is parametrized by θ, which
we optimize by minimizing the expected loss over the distribution of tasks,
(cid:2)Eτφ∼PT (τ |φ)

(T )—the meta-loss:

D
(cid:2)LT (τφ)

T (θ)] , where

ET ∼D(T ) [

T (θ) := E

τ 1:K
θ

, θ(cid:3)(cid:3)

(3)

τ 1:K
θ ∼PT (τ |θ)

min
θ

L

L

|

where τθ and τφ are trajectories obtained under πθ and πφ, respectively.

In general, we can think of the task, trajectories, and policies, as random variables (Fig. 1a), where φ
θ, τ1:k). The meta-update (2) is equivalent to
is generated from some conditional distribution PT (φ
(cid:16)
(cid:17)2. To optimize (3),
assuming the delta distribution, PT (φ
θ, τ1:k) := δ
|
T is as follows:
we can use the policy gradient method (Williams, 1992), where the gradient of
(cid:35)(cid:35)

k=1 LT (τk)

(cid:80)K

1
K

∇

|
θ

−

L

α

(cid:34)

(cid:34)

θ

θ

∇

L

T (θ) = E

τ 1:K
θ ∼PT (τ |θ)
τφ∼PT (τ |φ)

LT (τφ)

∇

θ log πφ(τφ) +

θ

∇

log πθ(τ k
θ )

(4)

K
(cid:88)

k=1

The expected loss on a task,
T , can be optimized with trust-region policy (TRPO) (Schulman et al.,
2015a) or proximal policy (PPO) (Schulman et al., 2017) optimization methods. For details and
derivations please refer to Appendix A.

L

3.2 CONTINUOUS ADAPTATION VIA META-LEARNING

(T ).
In the classical multi-task setting, we make no assumptions about the distribution of tasks,
D
When the environment is nonstationary, we can see it as a sequence of stationary tasks on a certain
(T ) is
timescale where the tasks correspond to different dynamics of the environment. Then,
deﬁned by the environment changes, and the tasks become sequentially dependent. Hence, we would
like to exploit this dependence between consecutive tasks and meta-learn a rule that keeps updating
the policy in a way that minimizes the total expected loss encountered during the interaction with the
changing environment. For instance, in the multi-agent setting, when playing against an opponent
that changes its strategy incrementally (e.g., due to learning), our agent should ideally meta-learn to
anticipate the changes and update its policy accordingly.

D

In the probabilistic language, our nonstationary environment is equivalent to a distribution of tasks
represented by a Markov chain (Fig. 1b). The goal is to minimize the expected loss over the chain of
tasks of some length L:

EP(T0),P(Ti+1|Ti)

min
θ

(cid:35)

Ti,Ti+1(θ)

(cid:34) L
(cid:88)

L

i=1

(5)

2Grant et al. (2018) similarly reinterpret adaptation updates (in non-RL settings) as Bayesian inference.

4

Policy parameter spacePublished as a conference paper at ICLR 2018

|

P

P

(Ti+1

(T0) and

Ti) denote the initial and the transition probabilities in the Markov chain
Here,
of tasks. Note that (i) we deal with Markovian dynamics on two levels of hierarchy, where the upper
level is the dynamics of the tasks and the lower level is the MDPs that represent particular tasks,
and (ii) the objectives,
Ti,Ti+1 , will depend on the way the meta-learning process is deﬁned. Since
we are interested in adaptation updates that are optimal with respect to the Markovian transitions
between the tasks, we deﬁne the meta-loss on a pair of consecutive tasks as follows:
i,θ , θ(cid:3)(cid:105)
(cid:104)
τ 1:K

(cid:2)LTi+1 (τi+1,φ)

Ti,Ti+1(θ) := E

Eτi+1,φ∼PTi+1 (τ |φ)

τ 1:K
i,θ ∼PTi (τ |θ)

(6)

L

The principal difference between the loss in (3) and (6) is that trajectories τ 1:K
come from the
i,θ
current task, Ti, and are used to construct a policy, πφ, that is good for the upcoming task, Ti+1.
Note that even though the policy parameters, φi, are sequentially dependent (Fig. 1b), in (6) we
always start from the initial parameters, θ 3. Hence, optimizing
Ti,Ti+1(θ) is equivalent to truncated
backpropagation through time with a unit lag in the chain of tasks.
To construct parameters of the policy for task Ti+1, we start from θ and do multiple4 meta-gradient
steps with adaptive step sizes as follows (assuming the number of steps is M ):

L

L

|

φ0

i := θ,

φm
i

:= φm−1
i

τ 1:K
θ ∼
αm

−

PTi(τ

∇φm−1

i

θ),
(cid:16)

|
LTi

(cid:17)

τ 1:K
i,φm−1
i
(cid:16)

, m = 1, . . . , M
(cid:17)

1,

−

(7)

φi+1 := φM −1

τ 1:K
i,φM −1
i
M
m=1 is a set of meta-gradient step sizes that are optimized jointly with θ. The computation
where
}
graph for the meta-update is given in Fig. 1c. The expression for the policy gradient is the same as
in (4) but with the expectation is now taken w.r.t. to both Ti and Ti+1:

∇φM −1

LTi

αM

αm

−

{

i

i

θ,α

∇

Ti,Ti+1(θ, α) =

L

(cid:34)

E

τ 1:K
i,θ ∼PTi (τ |θ)
τi+1,φ∼PTi+1 (τ |φ)

LTi+1(τi+1,φ)

(cid:34)

∇

θ,α log πφ(τi+1,φ) +

(cid:35)(cid:35)

(8)

log πθ(τ k

i,θ)

K
(cid:88)

k=1

θ

∇

More details and the analog of the policy gradient theorem for our setting are given in Appendix A.

Note that computing adaptation updates requires interacting with the environment under πθ while
Ti,Ti+1 , requires using πφ, and hence, interacting with each task in the
computing the meta-loss,
sequence twice. This is often impossible at execution time, and hence we use slightly different
algorithms at training and execution times.

L

P

Meta-learning at training time. Once we have access to a distribution over pairs of consecutive
tasks5,
(Ti−1, Ti), we can meta-learn the adaptation updates by optimizing θ and α jointly with a
gradient method, as given in Algorithm 1. We use πθ to collect trajectories from Ti and πφ when
interacting with Ti+1. Intuitively, the algorithm is searching for θ and α such that the adaptation
update (7) computed on the trajectories from Ti brings us to a policy, πφ, that is good for solving
Ti+1. The main assumption here is that the trajectories from Ti contain some information about Ti+1.
Note that we treat adaptation steps as part of the computation graph (Fig. 1c) and optimize θ and α
via backpropagation through the entire graph, which requires computing second order derivatives.

Adaptation at execution time. Note that to compute unbiased adaptation gradients at training time,
we have to collect experience in Ti using πθ. At test time, due to environment nonstationarity, we
usually do not have the luxury to access to the same task multiple times. Thus, we keep acting
according to πφ and re-use past experience to compute updates of φ for each new incoming task (see
Algorithm 2). To adjust for the fact that the past experience was collected under a policy different
from πθ, we use importance weight correction. In case of single step meta-update, we have:

φi := θ

α

1
K

−

K
(cid:88)

k=1

(cid:19)

(cid:18) πθ(τ k)
πφi−1(τ k)

∇

θLTi−1(τ k),

τ 1:K

PTi−1 (τ

φi−1),

|

∼

(9)

3This is due to stability considerations. We ﬁnd empirically that optimization over sequential updates from
φi to φi+1 is unstable, often tends to diverge, while starting from the same initialization leads to better behavior.
4Empirically, it turns out that constructing φ via multiple meta-gradient steps (between 2 and 5) with adaptive

step sizes tends yield better results in practice.

5Given a sequences of tasks generated by a nonstationary environment, T1, T2, T3, . . . , TL, we use the set of

all pairs of consecutive tasks, {(Ti−1, Ti)}L

i=1, as the training distribution.

5

Published as a conference paper at ICLR 2018

(a)

(b)

(c)

Fig. 2: (a) The three types of agents used in experiments. The robots differ in the anatomy: the number of legs,
their positions, and constraints on the thigh and knee joints. (b) The nonstationary locomotion environment. The
torques applied to red-colored legs are scaled by a dynamically changing factor. (c) RoboSumo environment.

where πφi−1 and πφi are used to rollout from Ti−1 and Ti, respectively. Extending importance weight
correction to multi-step updates is straightforward and requires simply adding importance weights to
each of the intermediate steps in (7).

4 ENVIRONMENTS

We have designed a set of environments for testing different aspects of continuous adaptation methods
in two scenarios: (i) simple environments that change from episode to episode according to some un-
derlying dynamics, and (ii) a competitive multi-agent environment, RoboSumo, that allows different
agents to play sequences of games against each other and keep adapting to incremental changes in
each other’s policies. All our environments are based on MuJoCo physics simulator (Todorov et al.,
2012), and all agents are simple multi-leg robots, as shown in Fig. 2a.

4.1 DYNAMIC

First, we consider the problem of robotic locomotion in a changing environment. We use a six-leg
agent (Fig. 2b) that observes the absolute position and velocity of its body, the angles and velocities
of its legs, and it acts by applying torques to its joints. The agent is rewarded proportionally to its
moving speed in a ﬁxed direction. To induce nonstationarity, we select a pair of legs of the agent and
scale down the torques applied to the corresponding joints by a factor that linearly changes from 1 to
0 over the course of 7 episodes. In other words, during the ﬁrst episode all legs are fully functional,
while during the last episode the agent has two legs fully paralyzed (even though the policy can
generate torques, they are multiplied by 0 before being passed to the environment). The goal of
the agent is to learn to adapt from episode to episode by changing its gait so that it is able to move
with a maximal speed in a given direction despite the changes in the environment (cf. Cully et al.,
2015). Also, there are 15 ways to select a pair of legs of a six-leg creature which gives us 15 different
nonstationary environments. This allows us to use a subset of these environments for training and a
separate held out set for testing. The training and testing procedures are described in the next section.

4.2 COMPETITIVE

Our multi-agent environment, RoboSumo, allows agents to compete in the 1-vs-1 regime following
the standard sumo rules6. We introduce three types of agents, Ant, Bug, and Spider, with different
anatomies (Fig. 2a). During the game, each agent observes positions of itself and the opponent, its
own joint angles, the corresponding velocities, and the forces exerted on its own body (i.e., equivalent
of tactile senses). The action spaces are continuous.

Iterated adaptation games. To test adaptation, we deﬁne the iterated adaptation game (Fig. 3)—a
game between a pair of agents that consists of K rounds each of which consists of one or more ﬁxed
length episodes (500 time steps each). The outcome of each round is either win, loss, or draw. The
agent that wins the majority of rounds (with at least 5% margin) is declared the winner of the game.
There are two distinguishing aspects of our setup: First, the agents are trained either via pure self-play
or versus opponents from a ﬁxed training collection. At test time, they face a new opponent from a
testing collection. Second, the agents are allowed to learn (or adapt) at test time. In particular, an

6To win, the agent has to push the opponent out of the ring or make the opponent’s body touch the ground.

6

Published as a conference paper at ICLR 2018

Fig. 3: An agent competes with an opponent in an iterated adaptation games that consist of multi-episode rounds.
The agent wins a round if it wins the majority of episodes (wins and losses illustrated with color). Both the agent
and its opponent may update their policies from round to round (denoted by the version number).

agent should exploit the fact that it plays against the same opponent multiple consecutive rounds and
try to adjust its behavior accordingly. Since the opponent may also be adapting, the setup allows to
test different continuous adaptation strategies, one versus the other.

Reward shaping. In RoboSumo, rewards are naturally sparse: the winner gets +2000, the loser is
penalized for -2000, and in case of a draw both opponents receive -1000 points. To encourage fast
learning at the early stages of training, we shape the rewards given to agents in the following way:
the agent (i) gets reward for staying closer to the center of the ring, for moving towards the opponent,
and for exerting forces on the opponent’s body, and (ii) gets penalty inversely proportional to the
opponent’s distance to the center of the ring. At test time, the agents continue having access to the
shaped reward as well and may use it to update their policies. Throughout our experiments, we use
discounted rewards with the discount factor, γ = 0.995. More details are in Appendix D.2.

Calibration. To study adaptation, we need a well-calibrated environment in which none of the agents
has an initial advantage. To ensure the balance, we increased the mass of the weaker agents (Ant
and Spider) such that the win rates in games between one agent type versus the other type in the
non-adaptation regime became almost equal (for details on calibration see Appendix D.3).

5 EXPERIMENTS

Our goal is to test different adaptation strategies in the proposed nonstationary RL settings. However,
it is known that the test-time behavior of an agent may highly depend on a variety of factors besides
the chosen adaptation method, including training curriculum, training algorithm, policy class, etc.
Hence, we ﬁrst describe the precise setup that we use in our experiments to eliminate irrelevant
factors and focus on the effects of adaptation. Most of the low-level details are deferred to appendices.
Video highlights of our experiments are available at https://goo.gl/tboqaN.

5.1 THE SETUP

Policies. We consider 3 types of policy networks: (i) a 2-layer MLP, (ii) embedding (i.e., 1
fully-connected layer replicated across the time dimension) followed by a 1-layer LSTM, and
(iii) RL2 (Duan et al., 2016) of the same architecture as (ii) which additionally takes previous reward
and done signals as inputs at each step, keeps the recurrent state throughout the entire interaction
with a given environment (or an opponent), and resets the state once the latter changes. For advantage
functions, we use networks of the same structure as for the corresponding policies and have no
parameter sharing between the two. Our meta-learning agents use the same policy and advantage
function structures as the baselines and learn a 3-step meta-update with adaptive step sizes as given
in (7). Illustrations and details on the architectures are given in Appendix B.

Meta-learning. We compute meta-updates via gradients of the negative discounted rewards received
during a number of previous interactions with the environment. At training time, meta-learners
interact with the environment twice, ﬁrst using the initial policy, πθ, and then the meta-updated
policy, πφ. At test time, the agents are limited to interacting with the environment only once, and
hence always act according to πφ and compute meta-updates using importance-weight correction
(see Sec. 3.2 and Algorithm 2). Additionally, to reduce the variance of the meta-updates at test time,
the agents store the experience collected during the interaction with the test environment (and the
corresponding importance weights) into the experience buffer and keep re-using that experience

7

Round 1Round 2Round 3Round KOpponent:version 1version 2version 3version KAgent:Episodes:Published as a conference paper at ICLR 2018

Fig. 4: Episodic rewards for 7 consecutive episodes in 3 held out nonstationary locomotion environments. To
evaluate adaptation strategies, we ran each of them in each environment for 7 episodes followed by a full reset of
the environment, policy, and meta-updates (repeated 50 times). Shaded regions are 95% conﬁdence intervals.
Best viewed in color.

to update πφ as in (7). The size of the experience buffer is ﬁxed to 3 episodes for nonstationary
locomotion and 75 episodes for RoboSumo. More details are given in Appendix C.1.

Adaptation baselines. We consider the following three baseline strategies:

(i) naive (or no adaptation),
(ii) implicit adaptation via RL2, and
(iii) adaptation via tracking (Sutton et al., 2007) that keeps doing PPO updates at execution time.

Training in nonstationary locomotion. We train all methods on the same collection of nonstationary
locomotion environments constructed by choosing all possible pairs of legs whose joint torques are
scaled except 3 pairs that are held out for testing (i.e., 12 training and 3 testing environments for
the six-leg creature). The agents are trained on the environments concurrently, i.e., to compute a
policy update, we rollout from all environments in parallel and then compute, aggregate, and average
the gradients (for details, see Appendix C.2). LSTM policies retain their state over the course of 7
episodes in each environment. Meta-learning agents compute meta-updates for each nonstationary
environment separately.

Training in RoboSumo. To ensure consistency of the training curriculum for all agents, we ﬁrst
pre-train a number of policies of each type for every agent type via pure self-play with the PPO
algorithm (Schulman et al., 2017; Bansal et al., 2018). We snapshot and save versions of the pre-
trained policies at each iteration. This lets us train other agents to play against versions of the
pre-trained opponents at various stages of mastery. Next, we train the baselines and the meta-learning
agents against the pool of pre-trained opponents7 concurrently. At each iteration k we (a) randomly
select an opponent from the training pool, (b) sample a version of the opponent’s policy to be in [1, k]
(this ensures that even when the opponent is strong, sometimes an undertrained version is selected
which allows the agent learn to win at early stages), and (c) rollout against that opponent. All baseline
policies are trained with PPO; meta-learners also used PPO as the outer loop for optimizing θ and α
parameters. We retain the states of the LSTM policies over the course of interaction with the same
version of the same opponent and reset it each time the opponent version is updated. Similarly to
the locomotion setup, meta-learners compute meta-updates for each opponent in the training pool
separately. A more detailed description of the distributed training is given in Appendix C.2.

Experimental design. We design our experiments to answer the following questions:

•

•

When the interaction with the environment before it changes is strictly limited to one or very
few episodes, what is the behavior of different adaptation methods in nonstationary locomotion
and competitive multi-agent environments?
What is the sample complexity of different methods, i.e., how many episodes is required for
a method to successfully adapt to the changes? We test this by controlling the amount of
experience the agent is allowed to get form the same environment before it changes.

7In competitive multi-agent environments, besides self-play, there are plenty of ways to train agents, e.g.,
train them in pairs against each other concurrently, or randomly match and switch opponents each few iterations.
We found that concurrent training often leads to an unbalanced population of agents that have been trained under
vastly different curricula and introduces spurious effects that interfere with our analysis of adaptation. Hence,
we leave the study of adaptation in naturally emerging curricula in multi-agent settings to the future work.

8

135705001000TotalepisodicrewardBacktwolegs1357Consecutiveepisodes05001000Middletwolegs135705001000FronttwolegsPolicy+adaptationmethodMLPMLP+PPO-trackingMLP+meta-updatesLSTMLSTM+PPO-trackingLSTM+meta-updatesRL2Published as a conference paper at ICLR 2018

Fig. 5: Win rates for different adaptation strategies in iterated games versus 3 different pre-trained opponents.
At test time, both agents and opponents started from versions 700. Opponents’ versions were increasing with
each consecutive round as if they were learning via self-play, while agents were allowed to adapt only from the
limited experience with a given opponent. Each round consisted of 3 episodes. Each iterated game was repeated
100 times; shaded regions denote bootstrapped 95% conﬁdence intervals; no smoothing. Best viewed in color.

Additionally, we ask the following questions speciﬁc to the competitive multi-agent setting:

•

•

Given a diverse population of agents that have been trained under the same curriculum, how do
different adaptation methods rank in a competition versus each other?
When the population of agents is evolved for several generations—such that the agents interact
with each other via iterated adaptation games, and those that lose disappear while the winners
get duplicated—what happens with the proportions of different agents in the population?

5.2 ADAPTATION IN THE FEW-SHOT REGIME AND SAMPLE COMPLEXITY

Few-shot adaptation in nonstationary locomotion environments. Having trained baselines and
meta-learning policies as described in Sec. 5.1, we selected 3 testing environments that corresponded
to disabling 3 different pairs of legs of the six-leg agent: back, middle, and front legs. The results are
presented on Fig. 4. Three observations: First, during the very ﬁrst episode, the meta-learned initial
policy, πθ(cid:63) , turns out to be suboptimal for the task (it underperforms compared to other policies).
However, after 1-2 episodes (and environment changes), it starts performing on par with other policies.
Second, by the 6th and 7th episodes, meta-updated policies perform much better than the rest. Note
that we use 3 gradient meta-updates for the adaptation of the meta-learners; the meta-updates are
computed based on experience collected during the previous 2 episodes. Finally, tracking is not able
to improve upon the baseline without adaptation and sometimes leads to even worse results.

Adaptation in RoboSumo under the few-shot constraint. To evaluate different adaptation methods
in the competitive multi-agent setting consistently, we consider a variation of the iterated adaptation
game, where changes in the opponent’s policies at test time are pre-determined but unknown to the

9

02550751000.20.40.6Winrate0255075100Consecutiverounds0.20.40.602550751000.20.40.6Opponent:AntOpponent:BugOpponent:SpiderAgent:SpiderRL2LSTM+PPO-trackingLSTM+meta-updates02550751000.20.40.60.8Winrate0255075100Consecutiverounds0.20.40.60.802550751000.20.40.60.8Opponent:AntOpponent:BugOpponent:SpiderAgent:BugRL2LSTM+PPO-trackingLSTM+meta-updates02550751000.20.40.6Winrate0255075100Consecutiverounds0.00.20.40.602550751000.20.40.6Opponent:AntOpponent:BugOpponent:SpiderAgent:AntRL2LSTM+PPO-trackingLSTM+meta-updatesPublished as a conference paper at ICLR 2018

Fig. 6: The effect of increased number of episodes per round in the iterated games versus a learning opponent.

agents. In particular, we pre-train 3 opponents (1 of each type, Fig. 2a) with LSTM policies with
PPO via self-play (the same way as we pre-train the training pool of opponents, see Sec. 5.1) and
snapshot their policies at each iteration. Next, we run iterated games between our trained agents that
use different adaptation algorithms versus policy snapshots of the pre-trained opponents. Crucially,
the policy version of the opponent keeps increasing from round to round as if it was training via
self-play8. The agents have to keep adapting to increasingly more competent versions of the opponent
(see Fig. 3). This setup allows us to test different adaptation strategies consistently against the same
learning opponents.

The results are given on Fig. 5. We note that meta-learned adaptation strategies, in most cases, are
able to adapt and improve their win-rates within about 100 episodes of interaction with constantly
improving opponents. On the other hand, performance of the baselines often deteriorates during the
rounds of iterated games. Note that the pre-trained opponents were observing 90 episodes of self-play
per iteration, while the agents have access to only 3 episodes per round.

Sample complexity of adaptation in RoboSumo. Meta-learning helps to ﬁnd an update suitable
for fast or few-shot adaptation. However, how do different adaptation methods behave when more
experience is available? To answer this question, we employ the same setup as previously and vary
the number of episodes per round in the iterated game from 3 to 90. Each iterated game is repeated
20 times, and we measure the win-rates during the last 25 rounds of the game.

The results are presented on Fig. 6. When the number of episodes per round goes above 50, adaptation
via tracking technically turns into “learning at test time,” and it is able to learn to compete against the
self-trained opponents that it has never seen at training time. The meta-learned adaptation strategy
performed near constantly the same in both few-shot and standard regimes. This suggests that the
meta-learned strategy acquires a particular bias at training time that allows it to perform better from
limited experience but also limits its capacity of utilizing more data. Note that, by design, the
meta-updates are ﬁxed to only 3 gradient steps from θ(cid:63) with step-sizes α(cid:63) (learned at training), while
tracking keeps updating the policy with PPO throughout the iterated game. Allowing for meta-updates
that become more ﬂexible with the availability of data can help to overcome this limitation. We leave
this to future work.

5.3 EVALUATION ON THE POPULATION-LEVEL

Combining different adaptation strategies with different policies and agents of different morphologies
puts us in a situation where we have a diverse population of agents which we would like to rank
according to the level of their mastery in adaptation (or ﬁnd the “ﬁttest”). To do so, we employ
TrueSkill (Herbrich et al., 2007)—a metric similar to the ELO rating, but more popular in 1-vs-1
competitive video-games.

In this experiment, we consider a population of 105 trained agents: 3 agent types, 7 different policy
and adaptation combinations, and 5 different stages of training (from 500 to 2000 training iterations).
(25, 25/3) and the default
First, we assume that the initial distribution of any agent’s skill is
distance that guarantees about 76% of winning, β = 4.1667. Next, we randomly generate 1000
matches between pairs of opponents and let them adapt while competing with each other in 100-round
iterated adaptation games (states of the agents are reset before each game). After each game, we

N

8At the beginning of the iterated game, both agents and their opponent start from version 700, i.e., from the

policy obtained after 700 iterations (PPO epochs) of learning to ensure that the initial policy is reasonable.

10

02550750.20.30.40.50.6WinrateAntvsAnt0255075Episodesperround0.20.30.40.50.6BugvsBug02550750.20.30.40.50.6SpidervsSpiderRL2LSTM+PPO-trackingLSTM+meta-updatesNoadaptationPublished as a conference paper at ICLR 2018

record the outcome and updated our belief about the skill of the corresponding agents using the
TrueSkill algorithm9. The distributions of the skill for the agents of each type after 1000 iterated
adaptation games between randomly selected players from the pool are visualized in Fig. 7.

Fig. 7: TrueSkill for the top-performing MLP- and LSTM-based agents. TrueSkill was computed based on
outcomes (win, loss, or draw) in 1000 iterated adaptation games (100 consecutive rounds per game, 3 episodes
per round) between randomly selected pairs of opponents from a population of 105 pre-trained agents.

There are a few observations we can make: First, recurrent policies were dominant. Second, adaptation
via RL2 tended to perform equally or a little worse than plain LSTM with or without tracking in this
setup. Finally, agents that meta-learned adaptation rules at training time, consistently demonstrated
higher skill scores in each of the categories corresponding to different policies and agent types.

Finally, we enlarge the population from 105 to 1050 agents by duplicating each of them 10 times and
evolve it (in the “natural selection” sense) for several generations as follows. Initially, we start with
a balanced population of different creatures. Next, we randomly match 1000 pairs of agents, make
them play iterated adaptation games, remove the agents that lost from the population and duplicate the
winners. The same process is repeated 10 times. The result is presented in Fig 8. We see that many
agents quickly disappear form initially uniform population and the meta-learners end up dominating.

Fig. 8: Evolution of a population of 1050 agents for 10 generations. Best viewed in color.

6 CONCLUSION AND FUTURE DIRECTIONS

In this work, we proposed a simple gradient-based meta-learning approach suitable for continuous
adaptation in nonstationary environments. The key idea of the method is to regard nonstationarity
as a sequence of stationary tasks and train agents to exploit the dependencies between consecutive
tasks such that they can handle similar nonstationarities at execution time. We applied our method to
nonstationary locomotion and within a competitive multi-agent setting. For the latter, we designed
the RoboSumo environment and deﬁned iterated adaptation games that allowed us to test various
aspects of adaptation strategies. In both cases, meta-learned adaptation rules were more efﬁcient than
the baselines in the few-shot regime. Additionally, agents that meta-learned to adapt demonstrated
the highest level of skill when competing in iterated games against each other.

The problem of continuous adaptation in nonstationary and competitive environments is far from
being solved, and this work is the ﬁrst attempt to use meta-learning in such setup. Indeed, our
meta-learning algorithm has a few limiting assumptions and design choices that we have made mainly
due to computational considerations. First, our meta-learning rule is to one-step-ahead update of the

9We used an implementation from http://trueskill.org/.

11

MLPLSTM203040TrueSkillSub-population:AntsMLPLSTM203040Sub-population:BugsMLPLSTM203040Sub-population:SpidersnoadaptationPPO-trackingmeta-updatesRL2012345678910Creaturegeneration(#)0255075100Proportion(%)AntsBugsSpidersPolicy+adaptationMLPMLP+PPO-trackingMLP+meta-updatesLSTMLSTM+PPO-trackingLSTM+meta-updatesRL2Published as a conference paper at ICLR 2018

policy and is computationally similar to backpropagation through time with a unit time lag. This
could potentially be extended to fully recurrent meta-updates that take into account the full history
of interaction with the changing environment. Additionally, our meta-updates were based on the
gradients of a surrogate loss function. While such updates explicitly optimized the loss, they required
computing second order derivatives at training time, slowing down the training process by an order of
magnitude compared to baselines. Utilizing information provided by the loss but avoiding explicit
backpropagation through the gradients would be more appealing and scalable. Finally, our approach
is unlikely to work with sparse rewards as the meta-updates use policy gradients and heavily rely on
the reward signal. Introducing auxiliary dense rewards designed to enable meta-learning is a potential
way to overcome this issue that we would like to explore in the future work.

ACKNOWLEDGEMENTS

We would like to thank Harri Edwards, Jakob Foerster, Aditya Grover, Aravind Rajeswaran, Vikash
Kumar, Yuhuai Wu and many others at OpenAI for helpful comments and fruitful discussions.

REFERENCES

Maruan Al-Shedivat, Avinava Dubey, and Eric P Xing. Contextual explanation networks. arXiv

preprint arXiv:1705.10301, 2017.

Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul,
and Nando de Freitas. Learning to learn by gradient descent by gradient descent. In Advances in
Neural Information Processing Systems, pp. 3981–3989, 2016.

Trapit Bansal, Jakub Pachocki, Szymon Sidor, Ilya Sutskever, and Igor Mordatch. Emergent com-
plexity via multi-agent competition. In International Conference on Learning Representations,
2018. URL https://openreview.net/forum?id=Sy0GnUxCb.

Samy Bengio, Yoshua Bengio, Jocelyn Cloutier, and Jan Gecsei. On the optimization of a synaptic
learning rule. In Preprints Conf. Optimality in Artiﬁcial and Biological Neural Networks, pp. 6–8.
Univ. of Texas, 1992.

Yoshua Bengio, Samy Bengio, and Jocelyn Cloutier. Learning a synaptic learning rule. Université

de Montréal, Département d’informatique et de recherche opérationnelle, 1990.

Michael Bowling. Convergence and no-regret in multiagent learning.

In Advances in neural

information processing systems, pp. 209–216, 2005.

Yongcan Cao, Wenwu Yu, Wei Ren, and Guanrong Chen. An overview of recent progress in the
study of distributed multi-agent coordination. IEEE Transactions on Industrial informatics, 9(1):
427–438, 2013.

Rich Caruana. Multitask learning. In Learning to learn, pp. 95–133. Springer, 1998.

Vincent Conitzer and Tuomas Sandholm. Awesome: A general multiagent learning algorithm that
converges in self-play and learns a best response against stationary opponents. Machine Learning,
67(1-2):23–43, 2007.

Antoine Cully, Jeff Clune, Danesh Tarapore, and Jean-Baptiste Mouret. Robots that can adapt like

animals. Nature, 521(7553):503–507, 2015.

Bruno C Da Silva, Eduardo W Basso, Ana LC Bazzan, and Paulo M Engel. Dealing with non-
stationary environments using context detection. In Proceedings of the 23rd international confer-
ence on Machine learning, pp. 217–224. ACM, 2006.

Yan Duan, John Schulman, Xi Chen, Peter L Bartlett, Ilya Sutskever, and Pieter Abbeel. Rl2: Fast
reinforcement learning via slow reinforcement learning. arXiv preprint arXiv:1611.02779, 2016.

Harrison Edwards and Amos Storkey. Towards a neural statistician. arXiv preprint arXiv:1606.02185,

2016.

12

Published as a conference paper at ICLR 2018

Chelsea Finn, Pieter Abbeel, and Sergey Levine. Lifelong few-shot learning. In Lifelong Learning: A

Reinforcement Learning Approach ICML workshop, 2017a.

Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of

deep networks. arXiv preprint arXiv:1703.03400, 2017b.

Jakob Foerster, Gregory Farquhar, Triantafyllos Afouras, Nantas Nardelli, and Shimon Whiteson.

Counterfactual multi-agent policy gradients. arXiv preprint arXiv:1705.08926, 2017a.

Jakob N Foerster, Richard Y Chen, Maruan Al-Shedivat, Shimon Whiteson, Pieter Abbeel, and Igor
Mordatch. Learning with opponent-learning awareness. arXiv preprint arXiv:1709.04326, 2017b.

Erin Grant, Chelsea Finn, Sergey Levine, Trevor Darrell, and Thomas Grifﬁths. Recasting gradient-
based meta-learning as hierarchical bayes. In International Conference on Learning Representa-
tions, 2018. URL https://openreview.net/forum?id=BJ_UL-k0b.

David Ha, Andrew Dai, and Quoc V Le. Hypernetworks. arXiv preprint arXiv:1609.09106, 2016.

Ralf Herbrich, Tom Minka, and Thore Graepel. TrueskillTM: a bayesian skill rating system. In

Advances in neural information processing systems, pp. 569–576, 2007.

Sepp Hochreiter, A Steven Younger, and Peter R Conwell. Learning to learn using gradient descent.

In International Conference on Artiﬁcial Neural Networks, pp. 87–94. Springer, 2001.

Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep

visuomotor policies. Journal of Machine Learning Research, 17(39):1–40, 2016.

Jiwei Li, Will Monroe, Alan Ritter, Michel Galley, Jianfeng Gao, and Dan Jurafsky. Deep reinforce-

ment learning for dialogue generation. arXiv preprint arXiv:1606.01541, 2016.

Ke Li and Jitendra Malik. Learning to optimize. arXiv preprint arXiv:1606.01885, 2016.

Ryan Lowe, Yi Wu, Aviv Tamar, Jean Harb, Pieter Abbeel, and Igor Mordatch. Multi-agent actor-
critic for mixed cooperative-competitive environments. arXiv preprint arXiv:1706.02275, 2017.

Michael McCloskey and Neal J Cohen. Catastrophic interference in connectionist networks: The

sequential learning problem. Psychology of learning and motivation, 24:109–165, 1989.

Richard Mealing and Jonathan L Shapiro. Opponent modelling by sequence prediction and lookahead
in two-player games. In International Conference on Artiﬁcial Intelligence and Soft Computing,
pp. 385–396. Springer, 2013.

Tom M Mitchell, William W Cohen, Estevam R Hruschka Jr, Partha Pratim Talukdar, Justin Betteridge,
Andrew Carlson, Bhavana Dalvi Mishra, Matthew Gardner, Bryan Kisiel, Jayant Krishnamurthy,
et al. Never ending learning. In AAAI, pp. 2302–2310, 2015.

Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,
Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control
through deep reinforcement learning. Nature, 518(7540):529–533, 2015.

Peng Peng, Quan Yuan, Ying Wen, Yaodong Yang, Zhenkun Tang, Haitao Long, and Jun Wang.
Multiagent bidirectionally-coordinated nets for learning to play starcraft combat games. arXiv
preprint arXiv:1703.10069, 2017.

Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. 2016.

Mark B Ring. Continual learning in reinforcement environments. PhD thesis, University of Texas at

Austin Austin, Texas 78712, 1994.

Mark B Ring. CHILD: A ﬁrst step towards continual learning. Machine Learning, 28(1):77–104,

1997.

Adam Santoro, Sergey Bartunov, Matthew Botvinick, Daan Wierstra, and Timothy Lillicrap. Meta-
In International conference on machine

learning with memory-augmented neural networks.
learning, pp. 1842–1850, 2016.

13

Published as a conference paper at ICLR 2018

Jurgen Schmidhuber. Evolutionary principles in self-referential learning. On learning how to learn:

The meta-meta-... hook.) Diploma thesis, Institut f. Informatik, Tech. Univ. Munich, 1987.

Jürgen Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent

networks. Learning, 4(1), 1992.

John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region
policy optimization. In Proceedings of the 32nd International Conference on Machine Learning
(ICML-15), pp. 1889–1897, 2015a.

John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-dimensional
continuous control using generalized advantage estimation. arXiv preprint arXiv:1506.02438,
2015b.

John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy

optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.

Daniel L Silver, Qiang Yang, and Lianghao Li. Lifelong machine learning systems: Beyond learning
algorithms. In AAAI Spring Symposium: Lifelong Machine Learning, volume 13, pp. 05, 2013.

David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche,
Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering
the game of go with deep neural networks and tree search. Nature, 529(7587):484–489, 2016.

Satinder Singh, Michael Kearns, and Yishay Mansour. Nash convergence of gradient dynamics
in general-sum games. In Proceedings of the Sixteenth conference on Uncertainty in artiﬁcial
intelligence, pp. 541–548. Morgan Kaufmann Publishers Inc., 2000.

Jake Snell, Kevin Swersky, and Richard S Zemel. Prototypical networks for few-shot learning. arXiv

preprint arXiv:1703.05175, 2017.

Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient meth-
ods for reinforcement learning with function approximation. In Advances in neural information
processing systems, pp. 1057–1063, 2000.

Richard S Sutton, Anna Koop, and David Silver. On the role of tracking in stationary environments.
In Proceedings of the 24th international conference on Machine learning, pp. 871–878. ACM,
2007.

Sebastian Thrun. Lifelong learning algorithms. Learning to learn, 8:181–209, 1998.

Sebastian Thrun and Lorien Pratt. Learning to learn. Springer, 1998.

Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026–
5033. IEEE, 2012.

Oriol Vinyals, Charles Blundell, Tim Lillicrap, Daan Wierstra, et al. Matching networks for one shot

learning. In Advances in Neural Information Processing Systems, pp. 3630–3638, 2016.

Jane X Wang, Zeb Kurth-Nelson, Dhruva Tirumala, Hubert Soyer, Joel Z Leibo, Remi Munos,
Charles Blundell, Dharshan Kumaran, and Matt Botvinick. Learning to reinforcement learn. arXiv
preprint arXiv:1611.05763, 2016.

Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement

learning. Machine learning, 8(3-4):229–256, 1992.

Chongjie Zhang and Victor R Lesser. Multi-agent learning with policy prediction. In AAAI, 2010.

14

Published as a conference paper at ICLR 2018

A DERIVATIONS AND THE POLICY GRADIENT THEOREM

In this section, we derive the policy gradient update for MAML as give in (4) as well as formulate
and equivalent of the policy gradient theorem (Sutton et al., 2000) in the learning-to-learn setting.

Our derivation is not bound to a particular form of the adaptation update. In general, we are interested
in meta-learning a procedure, fθ, parametrized by θ, which, given access to a limited experience
on a task, can produce a good policy for solving it. Note that fθ is responsible for both collecting
the initial experience and constructing the ﬁnal policy for the given task. For example, in case of
MAML (Finn et al., 2017b), fθ is represented by the initial policy, πθ, and the adaptation update
θLT (τ 1:K
rule (4) that produces πφ with φ := θ

).

α

θ
More formally, after querying K trajectories, τ 1:K
expected loss w.r.t. the distribution over tasks:

∇

−

θ

, we want to produce πφ that minimizes the

(θ) := ET ∼D(T )

(cid:104)

E

τ 1:K
θ ∼pT (τ |θ)

(cid:2)Eτφ∼pT (τ |φ)

(cid:2)LT (τφ)

τ 1:K
θ

(cid:3)(cid:3)(cid:105)

L

|
Note that the inner-most expectation is conditional on the experience, τ 1:K
, which our meta-learning
procedure, fθ, collects to produce a task-speciﬁc policy, πφ. Assuming that the loss LT (τ 1:K
) is
linear in trajectories, and using linearity of expectations, we can drop the superscript 1 : K and
denote the trajectory sampled under φθ for task Ti simply as τθ,i. At training time, we are given a
(T ) and can search for ˆθ close to optimal by optimizing
ﬁnite sample of tasks from the distribution
over the empirical distribution:

D

θ

θ

(10)

ˆθ := argmin

θ

(θ), where ˆ
ˆ
L
L

(θ) :=

1
N

N
(cid:88)

i=1

Eτθ,i∼pTi (τ |θ)

(cid:104)

Eτφ,i∼pTi (τ |φ) [LTi(τφ,i)

(cid:105)

τθ,i]

(11)

|

We re-write the objective function for task Ti in (11) more explicitly by expanding the expectations:

Ti(θ) := Eτθ,i∼pTi (τ |θ)
L

(cid:90)

(cid:104)
Eτφ,i∼pTi (τ |φ) [LTi(τφ,i)

(cid:105)

=

τθ,i]

|

(12)

LTi(τφ,i) PTi (τφ,i

φ) PTi (φ

|

|

θ, τθ,i) PTi (τθ,i

|

θ) dτφ,i dφ dτθ,i

Trajectories, τφ,i and τθ,i, and parameters φ of the policy πφ can be thought as random variables that
we marginalize out to construct the objective that depends on θ only. The adaptation update rule (4)
assumes the following PTi (φ

θ, τθ,i):

|

PTi (φ

|

θ, τθ,i) := δ

(cid:32)
θ

α

θ

∇

−

1
K

K
(cid:88)

k=1

(cid:33)

LTi(τ k

θ,i)

(13)

θ, τθ,i) differently, we may arrive at different meta-learning algo-
Note that by specifying PTi (φ
rithms. After plugging (13) into (12) and integrating out φ, we get the following expected loss for
task Ti as a function of θ:

|

L

Ti(θ) = Eτθ,i∼pTi (τ |θ)
(cid:32)

(cid:90)

(cid:104)

Eτφ,i∼pTi (τ |φ) [LTi(τφ,i)

(cid:105)
τθ,i]
(cid:33)

|

=

LTi(τφ,i) PTi

τφ,i

θ

α

θ

∇

−

|

LTi (τ k

θ,i)

PTi (τθ,i

θ) dτφ,i dτθ,i

|

1
K

K
(cid:88)

k=1

The gradient of (14) will take the following form:

Ti(θ) =

θ

∇

L

(cid:90)

(cid:90)

[LTi(τφ,i)

∇

θ log PTi (τφ,i

|

φ)] PTi (τφ,i

|

φ) PTi (τθ,i

|

θ) dτ dτθ,i+

[LTi (τ )

∇

θ log PTi (τθ,i

θ)] PTi (τ

|

|

φ) PTi (τθ,i

|

θ) dτ dτθ,i

(14)

(15)

where φ = φ(θ, τ 1:K
θ,i ) as given in (14). Note that the expression consists of two terms: the ﬁrst
term is the standard policy gradient w.r.t. the updated policy, πφ, while the second one is the policy
gradient w.r.t. the original policy, πφ, that is used to collect τ 1:K
. If we were to omit marginalization
θ,i

15

Published as a conference paper at ICLR 2018

of τ 1:K
θ,i
the gradient can be re-written in a more succinct form:

(as it was done in the original paper (Finn et al., 2017b)), the terms would disappear. Finally,

θ

∇

L

Ti (θ) = E

τ 1:K
θ,i ∼PTi (τ |θ)
τ ∼PTi (τ |φ)

(cid:34)

LTi(τ )

(cid:34)

∇

θ log πφ(τ ) +

K
(cid:88)

k=1

θ

∇

(cid:35)(cid:35)

log πθ(τk)

(16)

The update given in (16) is an unbiased estimate of the gradient as long as the loss LTi is simply the
sum of discounted rewards (i.e., it extends the classical REINFORCE algorithm (Williams, 1992) to
meta-learning). Similarly, we can deﬁne LTi that uses a value or advantage function and extend the
policy gradient theorem Sutton et al. (2000) to make it suitable for meta-learning.
Theorem 1 (Meta policy gradient theorem). For any MDP, gradient of the value function w.r.t. θ
takes the following form:

θV θ

T (x0) =

∇

Eτ1:K ∼pT (τ |θ)

(cid:34)

(cid:88)

dφ
T (x)

(cid:88)

a

|

∂πφ(a
∂θ
(cid:33)

x
(cid:34)(cid:32)

∂
∂θ

K
(cid:88)

k=1

Eτ1:K ∼pT (τ |θ)

log πθ(τk)

x)

(cid:35)
T (a, x)

Qφ

+

(cid:35)
T (a, x0)

x0)Qφ

,

(cid:88)

a

πφ(a

|

where dφ

T (x) is the stationary distribution under policy πφ.

Proof. We deﬁne task-speciﬁc value functions under the generated policy, πφ, as follows:

V φ
T (x0) = Eτ ∼pT (τ |φ)

Qφ

T (x0, a0) = Eτ ∼pT (τ |φ)

(cid:34) H
(cid:88)

t=k
(cid:34) H
(cid:88)

t=k

γtRT (xt)

γtRT (xt)

(cid:35)

x0

,

(cid:35)

x0, a0

,

|

|

(17)

(18)

where the expectations are taken w.r.t. the dynamics of the environment of the given task, T , and the
policy, πφ. Next, we need to marginalize out τ1:K:

T (x0) = Eτ1:K ∼pT (τ |θ)
V θ

Eτ ∼pT (τ |φ)

(cid:34)

(cid:34) H
(cid:88)

t=k

γtRT (xt)

(cid:35)(cid:35)

,

x0

|

and after the gradient w.r.t. θ, we arrive at:

θV θ

T (x0) =

∇

Eτ1:K ∼pT (τ |θ)

(cid:34)

(cid:88)

Eτ1:K ∼pT (τ |θ)

∂πφ(a
|
∂θ

x0)

Qφ

T (a, x0) + πφ(a

|

x0)

(cid:33)

log πθ(τk)

∂
∂θ

(cid:88)

a

πφ(a

|

x0)Qφ

a
(cid:34)(cid:32) K
(cid:88)

k=1

∂Qφ

T (a, x0)
∂θ
(cid:35)
T (a, x0)

,

(19)

(20)

(cid:35)

+

where the ﬁrst term is similar to the expression used in the original policy gradient theorem (Sutton
et al., 2000) while the second one comes from differentiating trajectories τ1:K that depend on θ.
Following Sutton et al. (2000), we unroll the derivative of the Q-function in the ﬁrst term and arrive
at the following ﬁnal expression for the policy gradient:

θV θ

T (x0) =

∇

Eτ1:K ∼pT (τ |θ)

(cid:34)

(cid:88)

dφ
T (x)

(cid:88)

a

|

∂πφ(a
∂θ
(cid:33)

x
(cid:34)(cid:32)

∂
∂θ

K
(cid:88)

k=1

Eτ1:K ∼pT (τ |θ)

log πθ(τk)

x)

(cid:35)
T (a, x)

Qφ

+

(21)

(cid:35)
T (a, x0)

x0)Qφ

(cid:88)

a

πφ(a

|

Remark 1. The same theorem is applicable to the continuous setting with the only changes in the
distributions used to compute expectations in (17) and (18). In particular, the outer expectation in
(17) should be taken w.r.t. pTi(τ

θ) while the inner expectation w.r.t. pTi+1(τ

φ).

|

|

16

Published as a conference paper at ICLR 2018

A.1 MULTIPLE ADAPTATION GRADIENT STEPS

All our derivations so far assumed single step gradient-based adaptation update. Experimentally, we
found that the multi-step version of the update often leads to a more stable training and better test
time performance. In particular, we construct φ via intermediate M gradient steps:

φ0 := θ,

φm := φm−1

τ 1:K
θ ∼
αm

−

φ := φM −1

−

αM

θ),
PT (τ
|
(cid:16)
∇φm−1LT
∇φM −1LT

(cid:17)

τ 1:K
φm−1
(cid:16)

τ 1:K
φM −1

, m = 1, . . . , M
(cid:17)

1,

−

(22)

where φm are intermediate policy parameters. Note that each intermediate step, m, requires interacting
with the environment and sampling intermediate trajectories, τ 1:K
φm . To compute the policy gradient,
we need to marginalize out all the intermediate random variables, πφm and τ 1:K
φm , m = 1, . . . , M .
The objective function (12) takes the following form:

T (θ) =
(cid:90)

L

LT (τ ) PT (τ

φ) PT

|

(cid:16)

φ

|

φM −1, τ 1:K

φM −1

(cid:17)

dτ dφ

×

φm+1(cid:17)

(cid:0)φm+1

PT

|

φm, τ 1:K
φm

(cid:1) dτ 1:K

φm+1dφm+1

×

(23)

M −2
(cid:89)

(cid:16)

PT

m=1
PT

(cid:0)τ 1:K
|
(cid:17)

τ 1:K
φm+1

|
θ(cid:1) dτ 1:K

(cid:16)

φm+1

φm, τ 1:K
φm

Since PT
at each intermediate steps are delta functions, the ﬁnal expression
for the multi-step MAML objective has the same form as (14), with integration taken w.r.t. all
intermediate trajectories. Similarly, an unbiased estimate of the gradient of the objective gets M
additional terms:

|

T = E

θ

∇

L

{τ 1:K

φm }M −1

m=0 ,τ

(cid:34)

(cid:34)

LT (τ )

θ log πφ(τ ) +

∇

M −1
(cid:88)
m=0 ∇

θ

K
(cid:88)

k=1

(cid:35)(cid:35)

log πφm(τ k

φm)

,

(24)

where the expectation is taken w.r.t. trajectories (including all intermediate ones). Again, note that at
training time we do not constrain the number of interactions with each particular environment and
do rollout using each intermediate policy to compute updates. At testing time, we interact with the
environment only once and rely on the importance weight correction as described in Sec. 3.2.

17

Published as a conference paper at ICLR 2018

(a) MLP

(b) LSTM

(c) RL2

Fig. 9: Policy and value function architectures.

B ADDITIONAL DETAILS ON THE ARCHITECTURES

The neural architectures used for our policies and value functions are illustrated in Fig. 9. Our MLP
architectures were memory-less and reactive. The LSTM architectures had used a fully connected
embedding layer (with 64 hidden units) followed by a recurrent layer (also with 64 units). The state
in LSTM-based architectures was kept throughout each episode and reset to zeros at the beginning
of each new episode. The RL2 architecture additionally took reward and done signals from the
previous time step and kept the state throughout the whole interactions with a given environment (or
opponent). The recurrent architectures were unrolled for T = 10 time steps and optimized with PPO
via backprop through time.

C ADDITIONAL DETAILS ON META-LEARNING AND OPTIMIZATION

C.1 META-UPDATES FOR CONTINUOUS ADAPTATION

Our meta-learned adaptation methods were used with MLP and LSTM policies (Fig. 9). The meta-
updates were based on 3 gradient steps with adaptive step sizes α were initialized with 0.001. There
are a few additional details to note:

1. θ and φ parameters were a concatenation of the policy and the value function parameters.
2. At the initial stages of optimization, meta-gradient steps often tended to “explode”, hence

we clipped them by values norms to be between -0.1 and 0.1.

3. We used different surrogate loss functions for the meta-updates and for the outer optimization.
For meta-updates, we used the vanilla policy gradients computed on the negative discounted
rewards, while for the outer optimization loop we used the PPO objective.

C.2 ON PPO AND ITS DISTRIBUTED IMPLEMENTATION

As mentioned in the main text and similar to (Bansal et al., 2018), large batch sizes were used
to ensure enough exploration throughout policy optimization and were critical for learning in the
competitive setting of RoboSumo. In our experiments, the epoch size of the PPO was set 32,000
episodes and the batch size was set to 8,000. The PPO clipping hyperparameter was set to (cid:15) = 0.2 and
the KL penalty was set to 0. In all our experiments, the learning rate (for meta-learning, the learning
rate for θ and α) was set to 0.0003. The generalized advantage function estimator (GAE) (Schulman
et al., 2015b) was optimized jointly with the policy (we used γ = 0.995 and λ = 0.95).

To train our agents in reasonable time, we used a distributed implementation of the PPO algorithm. To
do so, we versioned the agent’s parameters (i.e., kept parameters after each update and assigned it a
version number) and used a versioned queue for rollouts. Multiple worker machines were generating
rollouts in parallel for the most recent available version of the agent parameters and were pushing
them into the versioned rollout queue. The optimizer machine collected rollouts from the queue and
made a PPO optimization steps (see (Schulman et al., 2017) for details) as soon as enough rollouts
were available.

18

xtatMLP64 x 64VtsurrogatelossMLP64 x 64xtLSTM64 x 64atLSTM64 x 64Vtsurrogatelossrt-1LSTM64 x 64atLSTM64 x 64Vtsurrogatelossdt-1xtPublished as a conference paper at ICLR 2018

We trained agents on multiple environments simultaneously. In nonstationary locomotion, each
environment corresponded to a different pair of legs of the creature becoming dysfunctional. In
RoboSumo, each environment corresponded to a different opponent in the training pool. Simultane-
ous training was achieved via assigning these environments to rollout workers uniformly at random,
so that the rollouts in each mini-batch were guaranteed to come from all training environments.

D ADDITIONAL DETAILS ON THE ENVIRONMENTS

D.1 OBSERVATION AND ACTION SPACES

Both observation and action spaces in RoboSumo continuous. The observations of each agent
consist of the position of its own body (7 dimensions that include 3 absolute coordinates in the global
cartesian frame and 4 quaternions), position of the opponent’s body (7 dimensions), its own joint
angles and velocities (2 angles and 2 velocities per leg), and forces exerted on each part of its own
body (6 dimensions for torso and 18 for each leg) and forces exerted on the opponent’s torso (6
dimensions). All forces were squared and clipped at 100. Additionally, we normalized observations
using a running mean and clipped their values between -5 and 5. The action spaces had 2 dimensions
per joint. Table 1 summarizes the observation and action spaces for each agent type.

Table 1: Dimensionality of the observation and action spaces of the agents in RoboSumo.

Agent

Ant

Bug
Spider

Observation space

Self

Opponent

Action space

Coordinates Velocities

Forces

Coordinates

Forces

15

19
23

14

18
22

78

114
150

7

7
7

6

6
6

8

12
16

Note that the agents observe neither any of the opponents velocities, nor positions of the opponent’s
limbs. This allows us to keep the observation spaces consistent regardless of the type of the opponent.
However, even though the agents are blind to the opponent’s limbs, they can sense them via the forces
applied to the agents’ bodies when in contact with the opponent.

D.2 SHAPED REWARDS

In RoboSumo, the winner gets 2000 reward, the loser is penalized for -2000, and in case of draw both
agents get -1000. In addition to the sparse win/lose rewards, we used the following dense rewards to
encourage fast learning at the early training stages:

dopp

Quickly push the opponent outside. The agent got penalty at each time step proportional
to exp
Moving towards the opponent. Reward at each time step proportional to magnitude of the
velocity component towards the opponent.

where dopp was the distance of the opponent from the center of the ring.

{−

}

Hit the opponent. Reward proportional to the square of the total forces exerted on the
opponent’s torso.
Control penalty. The l2 penalty on the actions to prevent jittery/unnatural movements.

•

•

•

•

D.3 RO B OSU M O CALIBRATION

To calibrate the RoboSumo environment we used the following procedure. First, we trained each
agent via pure self-play with LSTM policy using PPO for the same number of iterations, tested
them one against the other (without adaptation), and recorded the win rates (Table 2). To ensure the
balance, we kept increasing the mass of the weaker agents and repeated the calibration procedure
until the win rates equilibrated.

19

Published as a conference paper at ICLR 2018

Table 2: Win rates for the ﬁrst agent in the 1-vs-1 RoboSumo without adaptation before and after calibration.

Masses (Ant, Bug, Spider)

Ant vs. Bug

Ant vs. Spider

Bug vs. Spider

Initial (10, 10, 10)
Calibrated (13, 10, 39)

25.2 ± 3.9%
50.6 ± 5.6%

83.6 ± 3.1%
51.6 ± 3.4%

90.2 ± 2.7%
51.7 ± 2.8%

E ADDITIONAL DETAILS ON EXPERIMENTS

E.1 AVERAGE WIN RATES

Table 3 gives average win rates for the last 25 rounds of iterated adaptation games played by different
agents with different adaptation methods (win rates for each episode are visualized in Figure 5).

Table 3: Average win-rates (95% CI) in the last 25 rounds of the 100-round iterated adaptation games between
different agents and different opponents. The base policy and value function were LSTMs with 64 hidden units.

Agent

Opponent

Adaptation Strategy

RL2

LSTM + PPO-tracking

LSTM + meta-updates

Ant

Bug

Spider

Ant
Bug
Spider

Ant
Bug
Spider

Ant
Bug
Spider

24.9 (5.4)%
21.0 (6.3)%
24.8 (10.5)%

33.5 (6.9)%
28.6 (7.4)%
45.8 (8.1)%

40.3 (9.7)%
38.4 (7.2)%
33.9 (7.2)%

30.0 (6.7)%
15.6 (7.1)%
27.6 (8.4)%

26.6 (7.4)%
21.2 (4.2)%
42.6 (12.9)%

48.0 (9.8)%
43.9 (7.1)%
42.2 (3.9)%

44.0 (7.7)%
34.6 (8.1)%
35.1 (7.7)%

39.5 (7.1)%
43.7 (8.0)%
52.0 (13.9)%

45.3 (10.9)%
48.4 (9.2)%
46.7 (3.8)%

E.2 TRUESKILL RANK OF THE TOP AGENTS

Rank Agent

TrueSkill rank*

1
2
3
4
5

6
7
8
9
10

Bug + LSTM-meta
Ant + LSTM-meta
Bug + LSTM-track
Ant + RL2
Ant + LSTM

Bug + MLP-meta
Ant + MLP-meta
Spider + MLP-meta
Spider + MLP
Bug + MLP-track

31.7
30.8
29.1
28.6
28.4

23.4
21.6
20.5
19.0
18.9

* The rank is a conservative estimate of the skill, r = µ − 3σ, to
ensure that the actual skill of the agent is higher with 99% conﬁdence.

Table 4 & Fig. 10: Top-5 agents with MLP and LSTM policies from the population ranked by TrueSkill. The
heatmap shows a priori win-rates in iterated games based on TrueSkill for the top agents against each other.

Since TrueSkill represents the belief about the skill of an agent as a normal distribution (i.e., with
two parameters, µ and σ), we can use it to infer a priori probability of an agent, a, winning against

20

12345678910Bug+LSTM-meta-1Ant+LSTM-meta-2Bug+LSTM-track-3Ant+LSTM-RL2-4Ant+LSTM-5Bug+MLP-meta-6Ant+MLP-meta-7Spd+MLP-meta-8Spd+MLP-9Bug+MLP-track-100.500.590.690.700.700.890.930.940.970.970.410.500.600.620.620.850.900.920.960.950.310.400.500.510.510.780.840.880.930.920.300.380.490.500.500.770.830.870.920.910.300.380.490.500.500.770.830.870.920.910.110.150.220.230.230.500.600.650.750.740.070.100.160.170.170.400.500.560.660.650.060.080.120.130.130.350.440.500.610.600.030.040.070.080.080.250.340.390.500.490.030.050.080.090.090.260.350.400.510.50Published as a conference paper at ICLR 2018

its opponent, o, as follows (Herbrich et al., 2007):
(cid:33)

(cid:32)

P (a wins o) = Φ

(cid:112)

µo
µa
a + σ2
2β2 + σ2
o

−

, where Φ(x) :=

(cid:20)

1 + erf

1
2

(cid:19)(cid:21)

(cid:18) x
√2

(25)

The ranking of the top-5 agents with MLP and LSTM policies according to their TrueSkill is given in
Tab. 1 and the a priori win rates in Fig. 10. Note that within the LSTM and MLP categories, the best
meta-learners are 10 to 25% more likely to win the best agents that use other adaptation strategies.

E.3

INTOLERANCE TO LARGE DISTRIBUTIONAL SHIFTS

Continuous adaptation via meta-learning assumes consistency in the changes of the environment or
the opponent. What happens if the changes are drastic? Unfortunately, the training process of our
meta-learning procedure turns out to be sensitive to such shifts and can diverge when the distributional
shifts from iteration to iteration are large. Fig. 11 shows the training curves for a meta-learning agent
with MLP policy trained against versions of an MLP opponent pre-trained via self-play. At each
iteration, we kept updating the opponent policy by 1 to 10 steps. The meta-learned policy was able to
achieve non-negative rewards by the end of training only when the opponent was changing up to 4
steps per iteration.

Fig. 11: Reward curves for a meta-learning agent trained against a learning opponent. Both agents were Ants
with MLP policies. At each iteration, the opponent was updating its policy for a given number of steps using
self-play, while the meta-learning agent attempted to learn to adapt to the distributional shifts. For each setting,
the training process was repeated 15 times; shaded regions denote 90% conﬁdence intervals.

21

050010001500Iteration−3000−2000−1000010002000Avg.rewardperepisode#ofopponentupdatesperiteration1step4steps7steps10steps